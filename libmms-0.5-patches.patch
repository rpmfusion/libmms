From 47c51e11e1969a5143eb953489921d4d632ff852 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 17:27:38 +0100
Subject: [PATCH 01/22] Add upstream patch checking for bitpos pointing outside the header

Note the check is wron <= should be <, will fix this in a separate
patch (to send back upstream).
---
 src/mms.c |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 0884f6a..bb37077 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1021,10 +1021,15 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
       
       /* forces the asf demuxer to not choose this stream */
       if (this->streams[i].bitrate_pos) {
-        this->asf_header[this->streams[i].bitrate_pos    ] = 0;
-        this->asf_header[this->streams[i].bitrate_pos + 1] = 0;
-        this->asf_header[this->streams[i].bitrate_pos + 2] = 0;
-        this->asf_header[this->streams[i].bitrate_pos + 3] = 0;
+        if (this->streams[i].bitrate_pos+3 <= ASF_HEADER_LEN) {
+          this->asf_header[this->streams[i].bitrate_pos    ] = 0;
+          this->asf_header[this->streams[i].bitrate_pos + 1] = 0;
+          this->asf_header[this->streams[i].bitrate_pos + 2] = 0;
+          this->asf_header[this->streams[i].bitrate_pos + 3] = 0;
+        } else {
+          lprintf("***LOG:*** -- "
+                  "libmms: attempt to write beyond asf header limit");
+        }
       }
     }
   }
-- 
1.7.0

From e714a1410c260cb551a6c17dd4b8137644b9dc12 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 17:39:54 +0100
Subject: [PATCH 02/22] Add support for GUID_ASF_EXTENDED_STREAM_PROPERTIES to mssh support

Patch from upstream bazar.
---
 src/asfheader.h |    6 ++-
 src/mmsh.c      |  158 +++++++++++++++++++++++++++++++++++++++++--------------
 2 files changed, 123 insertions(+), 41 deletions(-)

diff --git a/src/asfheader.h b/src/asfheader.h
index 09d94ed..2aaffb3 100644
--- a/src/asfheader.h
+++ b/src/asfheader.h
@@ -93,8 +93,9 @@
 #define GUID_ASF_AUDIO_CONCEAL_NONE            34
 #define GUID_ASF_CODEC_COMMENT1_HEADER         35
 #define GUID_ASF_2_0_HEADER                    36
+#define GUID_ASF_EXTENDED_STREAM_PROPERTIES    37
 
-#define GUID_END                               37
+#define GUID_END                               38
 
 
 /* asf stream types */
@@ -256,6 +257,9 @@ static const struct
     { "asf 2.0 header",
     { 0xd6e229d1, 0x35da, 0x11d1, { 0x90, 0x34, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xbe }} },
 
+    { "extended stream properties",
+    { 0x14e6a5cb, 0xc672, 0x4332, { 0x83, 0x99, 0xa9, 0x69, 0x52, 0x06, 0x5b, 0x5a }} },
+
 };
 
 #endif
diff --git a/src/mmsh.c b/src/mmsh.c
index cd5ef9b..bc9da5a 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -605,6 +605,47 @@ static int get_header (mms_io_t *io, mmsh_t *this) {
   }
 }
 
+static void interp_stream_properties(mmsh_t *this, int i) {
+  uint16_t flags;
+  uint16_t stream_id;
+  int      type;
+  int      encrypted;
+  int      guid;
+
+  guid = get_guid(this->asf_header, i);
+  switch (guid) {
+    case GUID_ASF_AUDIO_MEDIA:
+      type = ASF_STREAM_TYPE_AUDIO;
+      this->has_audio = 1;
+      break;
+
+    case GUID_ASF_VIDEO_MEDIA:
+    case GUID_ASF_JFIF_MEDIA:
+    case GUID_ASF_DEGRADABLE_JPEG_MEDIA:
+      type = ASF_STREAM_TYPE_VIDEO;
+      this->has_video = 1;
+      break;
+
+    case GUID_ASF_COMMAND_MEDIA:
+      type = ASF_STREAM_TYPE_CONTROL;
+      break;
+
+    default:
+      type = ASF_STREAM_TYPE_UNKNOWN;
+  }
+
+  flags = LE_16(this->asf_header + i + 48);
+  stream_id = flags & 0x7F;
+  encrypted = flags >> 15;
+
+  lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
+      stream_id, type, encrypted);
+
+  this->stream_types[stream_id] = type;
+  this->stream_ids[this->num_stream_ids] = stream_id;
+  this->num_stream_ids++;
+}
+
 static void interp_header (mms_io_t *io, mmsh_t *this) {
 
   int i;
@@ -651,46 +692,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
-        {
-	  uint16_t flags;
-          uint16_t stream_id;
-          int      type;
-	  int      encrypted;
-
-          guid = get_guid(this->asf_header, i);
-          switch (guid) {
-            case GUID_ASF_AUDIO_MEDIA:
-              type = ASF_STREAM_TYPE_AUDIO;
-              this->has_audio = 1;
-              break;
-
-            case GUID_ASF_VIDEO_MEDIA:
-	    case GUID_ASF_JFIF_MEDIA:
-	    case GUID_ASF_DEGRADABLE_JPEG_MEDIA:
-              type = ASF_STREAM_TYPE_VIDEO;
-              this->has_video = 1;
-              break;
-
-            case GUID_ASF_COMMAND_MEDIA:
-              type = ASF_STREAM_TYPE_CONTROL;
-              break;
-
-            default:
-              type = ASF_STREAM_TYPE_UNKNOWN;
-          }
-
-	  flags = LE_16(this->asf_header + i + 48);
-	  stream_id = flags & 0x7F;
-	  encrypted = flags >> 15;
-
-          lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
-		   stream_id, type, encrypted);
-
-          this->stream_types[stream_id] = type;
-          this->stream_ids[this->num_stream_ids] = stream_id;
-          this->num_stream_ids++;
-
-        }
+        interp_stream_properties(this, i);
         break;
 
       case GUID_ASF_STREAM_BITRATE_PROPERTIES:
@@ -714,6 +716,82 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
         }
         break;
 
+      case GUID_ASF_HEADER_EXTENSION:
+        {
+          int size = LE_32(this->asf_header + i + 18);
+          int j = 22;
+          int l;
+          lprintf("Extension header data size: %d\n", size);
+
+          while( (j+24) < length ) {
+            guid = get_guid(this->asf_header, i + j);
+            j += 16;
+
+            l = LE_64(this->asf_header + i + j);
+            j += 8;
+
+            switch(guid) {
+              case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
+                {
+                  int stream_no = LE_16(this->asf_header + i + j + 48);
+                  int name_count = LE_16(this->asf_header + i + j + 60);
+                  int ext_count = LE_16(this->asf_header + i + j + 62);
+                  int ext_j = 64;
+                  int x;
+
+                  lprintf ("l: %d\n", l);
+                  lprintf ("Stream No: %d\n", stream_no);
+                  lprintf ("Name count: %d\n", name_count);
+                  lprintf ("ext_count: %d\n", ext_count);
+
+                  // Loop through the number of stream names
+                  for(x=0; x<name_count; x++) {
+                    int lang_id_index;
+                    int stream_name_len;
+
+                    lang_id_index = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += 2;
+
+                    stream_name_len = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += stream_name_len + 2;
+
+                    lprintf ("Language id index: %d\n", lang_id_index);
+                    lprintf ("Stream name Len: %d\n", stream_name_len);
+                  }
+
+                  // Loop through the number of extension system info
+                  for(x=0; x<ext_count; x++) {
+                    ext_j += 18;
+                    int len = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += 4 + len;
+                  }
+
+                  lprintf ("ext_j: %d\n", ext_j);
+                  // Finally, we arrive at the interesting point: The optional Stream Property Object
+                  if( (ext_j+24) < l ) {
+                    guid = get_guid(this->asf_header, i + j + ext_j);
+                    if( guid == GUID_ASF_STREAM_PROPERTIES ) {
+                      interp_stream_properties(this, i + j + ext_j + 24);
+                    }
+                  } else {
+                    lprintf ("Sorry, field not long enough\n");
+                  }
+
+                }
+                break;
+              default:
+                lprintf ("unknown object (%d)\n", guid);
+                break;
+            }
+
+            if( l > 24 ) {
+              j += l-24;
+            }
+          }
+
+        }
+        break;
+
       case GUID_ASF_DATA:
         this->asf_num_packets = LE_64(this->asf_header + i + 40 - 24);
         lprintf("mmsh: num_packets: %d\n", (int)this->asf_num_packets);
-- 
1.7.0

From a19dacd3fcea1c53f015c22ad0bccb2e1dad0956 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 18:01:52 +0100
Subject: [PATCH 03/22] Fix bitrate_pos out of bounds check

---
 src/mms.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index bb37077..5503923 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1021,7 +1021,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
       
       /* forces the asf demuxer to not choose this stream */
       if (this->streams[i].bitrate_pos) {
-        if (this->streams[i].bitrate_pos+3 <= ASF_HEADER_LEN) {
+        if (this->streams[i].bitrate_pos+3 < ASF_HEADER_LEN) {
           this->asf_header[this->streams[i].bitrate_pos    ] = 0;
           this->asf_header[this->streams[i].bitrate_pos + 1] = 0;
           this->asf_header[this->streams[i].bitrate_pos + 2] = 0;
-- 
1.7.0

From 345662414b992475919b883a2b1cc5a95d7da2c4 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 18:02:55 +0100
Subject: [PATCH 04/22] Fix call of g_free on uninitialized pointer

---
 src/mmsh.c |    2 --
 1 files changed, 0 insertions(+), 2 deletions(-)

diff --git a/src/mmsh.c b/src/mmsh.c
index bc9da5a..ba6b944 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -1119,7 +1119,6 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
     uri->port = MMSH_PORT;
   }
   if (this->proxy_url) {
-    char * uri_string;
     this->proto = (uri->scheme) ? strdup(uri->scheme) : NULL;
     this->connect_host = (proxy_uri->hostname) ? strdup(proxy_uri->hostname) : NULL;
     this->connect_port = proxy_uri->port;
@@ -1131,7 +1130,6 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
     this->host_password = (uri->passwd) ? strdup(uri->passwd) : NULL;
     gnet_uri_set_scheme(uri,"http");
     this->uri = gnet_mms_helper(uri);
-    g_free(uri_string);
   } else {
     this->proto = (uri->scheme) ? strdup(uri->scheme) : NULL;
     this->connect_host = (uri->hostname) ? strdup(uri->hostname) : NULL;
-- 
1.7.0

From de961db5ae0a3e96ecba49c46f8c4a1cf12faca6 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 18:23:12 +0100
Subject: [PATCH 05/22] Add support for GUID_ASF_EXTENDED_STREAM_PROPERTIES to mms

Take the GUID_ASF_EXTENDED_STREAM_PROPERTIES support added to the
mmsh handling and add it to the mms code.
---
 src/mms.c |  165 +++++++++++++++++++++++++++++++++++++++++++++----------------
 1 files changed, 122 insertions(+), 43 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 5503923..70539e8 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -717,6 +717,52 @@ static int get_asf_header (mms_io_t *io, mms_t *this) {
   return 1;
 }
 
+static void interp_stream_properties(mms_t *this, int i)
+{
+  uint16_t flags;
+  uint16_t stream_id;
+  int      type;
+  int      encrypted;
+  int      guid;
+
+  guid = get_guid(this->asf_header, i);
+  switch (guid) {
+    case GUID_ASF_AUDIO_MEDIA:
+      type = ASF_STREAM_TYPE_AUDIO;
+      this->has_audio = 1;
+      break;
+
+    case GUID_ASF_VIDEO_MEDIA:
+    case GUID_ASF_JFIF_MEDIA:
+    case GUID_ASF_DEGRADABLE_JPEG_MEDIA:
+      type = ASF_STREAM_TYPE_VIDEO;
+      this->has_video = 1;
+      break;
+  
+    case GUID_ASF_COMMAND_MEDIA:
+      type = ASF_STREAM_TYPE_CONTROL;
+      break;
+
+    default:
+      type = ASF_STREAM_TYPE_UNKNOWN;
+  }
+
+  flags = LE_16(this->asf_header + i + 48);
+  stream_id = flags & 0x7F;
+  encrypted = flags >> 15;
+
+  lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
+           stream_id, type, encrypted);
+
+  if (this->num_stream_ids < ASF_MAX_NUM_STREAMS) {
+    this->streams[this->num_stream_ids].stream_type = type;
+    this->streams[this->num_stream_ids].stream_id = stream_id;
+    this->num_stream_ids++;
+  } else {
+    lprintf ("too many streams, skipping\n");
+  }
+}
+
 static void interp_asf_header (mms_t *this) {
 
   int i;
@@ -760,49 +806,7 @@ static void interp_asf_header (mms_t *this) {
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
-        {
-	  uint16_t flags;
-          uint16_t stream_id;
-          int      type;
-          int      encrypted;
-
-          guid = get_guid(this->asf_header, i);
-          switch (guid) {
-            case GUID_ASF_AUDIO_MEDIA:
-              type = ASF_STREAM_TYPE_AUDIO;
-              this->has_audio = 1;
-              break;
-    
-            case GUID_ASF_VIDEO_MEDIA:
-	    case GUID_ASF_JFIF_MEDIA:
-	    case GUID_ASF_DEGRADABLE_JPEG_MEDIA:
-              type = ASF_STREAM_TYPE_VIDEO;
-              this->has_video = 1;
-              break;
-          
-            case GUID_ASF_COMMAND_MEDIA:
-              type = ASF_STREAM_TYPE_CONTROL;
-              break;
-        
-            default:
-              type = ASF_STREAM_TYPE_UNKNOWN;
-          }
-
-          flags = LE_16(this->asf_header + i + 48);
-	  stream_id = flags & 0x7F;
-	  encrypted = flags >> 15;
-
-          lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
-		   stream_id, type, encrypted);
-
-	  if (this->num_stream_ids < ASF_MAX_NUM_STREAMS) {
-	    this->streams[this->num_stream_ids].stream_type = type;
-	    this->streams[this->num_stream_ids].stream_id = stream_id;
-	    this->num_stream_ids++;
-	  } else {
-	    lprintf ("too many streams, skipping\n");
-	  }
-        }
+        interp_stream_properties(this, i);
         break;
 
       case GUID_ASF_STREAM_BITRATE_PROPERTIES:
@@ -832,6 +836,81 @@ static void interp_asf_header (mms_t *this) {
         }
         break;
     
+      case GUID_ASF_HEADER_EXTENSION:
+        {
+          int size = LE_32(this->asf_header + i + 18);
+          int j = 22;
+          int l;
+          lprintf("Extension header data size: %d\n", size);
+
+          while( (j+24) < length ) {
+            guid = get_guid(this->asf_header, i + j);
+            j += 16;
+
+            l = LE_64(this->asf_header + i + j);
+            j += 8;
+
+            switch(guid) {
+              case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
+                {
+                  int stream_no = LE_16(this->asf_header + i + j + 48);
+                  int name_count = LE_16(this->asf_header + i + j + 60);
+                  int ext_count = LE_16(this->asf_header + i + j + 62);
+                  int ext_j = 64;
+                  int x;
+
+                  lprintf ("l: %d\n", l);
+                  lprintf ("Stream No: %d\n", stream_no);
+                  lprintf ("Name count: %d\n", name_count);
+                  lprintf ("ext_count: %d\n", ext_count);
+
+                  // Loop through the number of stream names
+                  for(x=0; x<name_count; x++) {
+                    int lang_id_index;
+                    int stream_name_len;
+
+                    lang_id_index = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += 2;
+
+                    stream_name_len = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += stream_name_len + 2;
+
+                    lprintf ("Language id index: %d\n", lang_id_index);
+                    lprintf ("Stream name Len: %d\n", stream_name_len);
+                  }
+
+                  // Loop through the number of extension system info
+                  for(x=0; x<ext_count; x++) {
+                    ext_j += 18;
+                    int len = LE_16(this->asf_header + i + j + ext_j);
+                    ext_j += 4 + len;
+                  }
+
+                  lprintf ("ext_j: %d\n", ext_j);
+                  // Finally, we arrive at the interesting point: The optional Stream Property Object
+                  if( (ext_j+24) < l ) {
+                    guid = get_guid(this->asf_header, i + j + ext_j);
+                    if( guid == GUID_ASF_STREAM_PROPERTIES ) {
+                      interp_stream_properties(this, i + j + ext_j + 24);
+                    }
+                  } else {
+                    lprintf ("Sorry, field not long enough\n");
+                  }
+
+                }
+                break;
+              default:
+                lprintf ("unknown object (%d)\n", guid);
+                break;
+            }
+
+            if( l > 24 ) {
+              j += l-24;
+            }
+          }
+        }
+        break;
+
       case GUID_ASF_DATA:
         this->asf_num_packets = LE_64(this->asf_header + i + 40 - 24);
         break;
-- 
1.7.0

From 7fcebf42002993c10c16fec7d64a552ba063ef58 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 18:27:55 +0100
Subject: [PATCH 06/22] Add check for ASF_MAX_NUM_STREAMS to mmsh handling code

---
 src/mmsh.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/src/mmsh.c b/src/mmsh.c
index ba6b944..81aec51 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -641,6 +641,12 @@ static void interp_stream_properties(mmsh_t *this, int i) {
   lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
       stream_id, type, encrypted);
 
+  if (stream_id >= ASF_MAX_NUM_STREAMS ||
+      this->num_stream_ids >= ASF_MAX_NUM_STREAMS) {
+    lprintf ("too many streams, skipping\n");
+    return;
+  }
+
   this->stream_types[stream_id] = type;
   this->stream_ids[this->num_stream_ids] = stream_id;
   this->num_stream_ids++;
-- 
1.7.0

From f0e4da3b591c11a79c870382a832916346c6ab0c Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Fri, 5 Feb 2010 18:36:49 +0100
Subject: [PATCH 07/22] Add check for bitpos pointing outside the header to mmsh

This was added to mssh handling by a patch a while ago, the same check is
necessary for plain mms handling.
---
 src/mmsh.c |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/mmsh.c b/src/mmsh.c
index 81aec51..827a90d 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -1044,10 +1044,15 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
 
       /* forces the asf demuxer to not choose this stream */
       if (this->bitrates_pos[this->stream_ids[i]]) {
-	this->asf_header[this->bitrates_pos[this->stream_ids[i]]]     = 0;
-	this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 1] = 0;
-	this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 2] = 0;
-	this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 3] = 0;
+        if (this->bitrates_pos[this->stream_ids[i]] + 3 < ASF_HEADER_SIZE) {
+	  this->asf_header[this->bitrates_pos[this->stream_ids[i]]]     = 0;
+	  this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 1] = 0;
+	  this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 2] = 0;
+	  this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 3] = 0;
+        } else {
+          lprintf("***LOG:*** -- "
+                  "libmms: attempt to write beyond asf header limit");
+        }
       }
     }
   }
-- 
1.7.0

From 21286345000c7931a56f1a1f3f919b9f47b50ed5 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sat, 6 Feb 2010 15:13:38 +0100
Subject: [PATCH 08/22] Make debug output configurable at runtime

---
 src/mms.c  |   16 +++++-----------
 src/mmsh.c |   10 ++--------
 2 files changed, 7 insertions(+), 19 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 70539e8..d519d0b 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -53,13 +53,7 @@
 #endif
 
 /********** logging **********/
-#define LOG_MODULE "mms"
-#define LOG_VERBOSE
-#ifdef DEBUG
-# define lprintf printf
-#else
-# define lprintf(x...)
-#endif
+#define lprintf(...) if (getenv("LIBMMS_DEBUG")) fprintf(stderr, __VA_ARGS__)
 
 #define __MMS_C__
 
@@ -575,7 +569,7 @@ static int get_packet_header (mms_io_t *io, mms_t *this, mms_packet_header_t *he
   return packet_type;
   
 error:
-  lprintf("read error, len=%d\n", len);
+  lprintf("read error, len=%ld\n", len);
   perror("Could not read packet header");
   return MMS_PACKET_ERR;
 }
@@ -830,7 +824,7 @@ static void interp_asf_header (mms_t *this) {
               this->streams[stream_index].bitrate = LE_32(this->asf_header + i + 4 + j * 6);
               this->streams[stream_index].bitrate_pos = i + 4 + j * 6;
               lprintf ("stream id %d, bitrate %d\n", stream_id, 
-                     this->[stream_index].bitrate);
+                     this->streams[stream_index].bitrate);
             }
           }
         }
@@ -920,7 +914,7 @@ static void interp_asf_header (mms_t *this) {
         break;
     }
 
-    lprintf ("length    : %lld\n", length);
+    lprintf ("length: %llu\n", (unsigned long long)length);
 
     if (length > 24) {
       i += length - 24;
@@ -1094,7 +1088,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
       this->scmd_body [ (i - 1) * 6 + 6 ] = 0x00;
       this->scmd_body [ (i - 1) * 6 + 7 ] = 0x00;
     } else {
-      lprintf("disabling stream %d\n", this->stream_ids[i]);
+      lprintf("disabling stream %d\n", this->streams[i].stream_id);
       this->scmd_body [ (i - 1) * 6 + 6 ] = 0x02;
       this->scmd_body [ (i - 1) * 6 + 7 ] = 0x00;
       
diff --git a/src/mmsh.c b/src/mmsh.c
index 827a90d..d002fbd 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -49,13 +49,7 @@
 #include <time.h>
 #include <assert.h>
 
-#define LOG_MODULE "mmsh"
-#define LOG_VERBOSE
-#ifdef DEBUG
-# define lprintf printf
-#else
-# define lprintf(x...)
-#endif
+#define lprintf(...) if (getenv("LIBMMS_DEBUG")) fprintf(stderr, __VA_ARGS__)
 
 /* cheat a bit and call ourselves mms.c to keep the code in mmsio.h clean */
 #define __MMS_C__
@@ -808,7 +802,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
         break;
     }
 
-    lprintf ("length    : %lld\n", length);
+    lprintf ("length: %llu\n", (unsigned long long)length);
 
     if (length > 24) {
       i += length - 24;
-- 
1.7.0

From c8fbc1f8362461891d88dc403ff4d493da9a4163 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sat, 6 Feb 2010 18:02:22 +0100
Subject: [PATCH 09/22] Don't fall back to lowest bitrate video stream when id 0 is the one we want

If the video stream we want has an id of 0, we would see that as
no stream found, and thus fall back to the lowest bitrate stream,
this patch fixes this.
---
 src/mms.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index d519d0b..8c69255 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1011,8 +1011,8 @@ static void mms_gen_guid(char guid[]) {
  */
 int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
   int     i;
-  int     video_stream = 0;
-  int     audio_stream = 0;
+  int     video_stream = -1;
+  int     audio_stream = -1;
   int     max_arate    = 0;
   int     min_vrate    = 0;
   int     min_bw_left  = 0;
@@ -1059,7 +1059,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
   }  
 
   /* choose the lower bitrate of */
-  if (!video_stream && this->has_video) {
+  if (video_stream == -1 && this->has_video) {
     for (i = 0; i < this->num_stream_ids; i++) {
       switch (this->streams[i].stream_type) {
         case ASF_STREAM_TYPE_VIDEO:
-- 
1.7.0

From f9e47af8e5246a836191c99561a9baede9f5e3d5 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 7 Feb 2010 20:00:48 +0100
Subject: [PATCH 10/22] Add error checking and reporting to mmsh get_foo functions

---
 src/mmsh.c |  112 ++++++++++++++++++++++++++++++++++++------------------------
 1 files changed, 67 insertions(+), 45 deletions(-)

diff --git a/src/mmsh.c b/src/mmsh.c
index d002fbd..9157c6d 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -80,6 +80,11 @@
 
 #define SCRATCH_SIZE             1024
 
+#define SUCCESS 0
+#define ERROR 1
+#define EOS 2
+#define GOT_HEADER_N_DATA 3
+
 static const char* mmsh_FirstRequest =
     "GET %s HTTP/1.0\r\n"
     "Accept: */*\r\n"
@@ -223,7 +228,7 @@ static off_t fallback_io_read(void *data, int socket, char *buf, off_t num)
   {
     ret = (off_t)read(socket, buf + len, num - len);
     if(ret == 0)
-      break; /* EOF */
+      break; /* EOS */
     if(ret < 0)
       switch(errno)
       {
@@ -466,8 +471,10 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
   /* read chunk header */
   read_len = io_read(io, this->s, chunk_header, CHUNK_HEADER_LENGTH);
   if (read_len != CHUNK_HEADER_LENGTH) {
+    if (read_len == 0)
+      return EOS;
     lprintf ("chunk header read failed, %d != %d\n", read_len, CHUNK_HEADER_LENGTH);
-    return 0;
+    return ERROR;
   }
   this->chunk_type       = LE_16 (&chunk_header[0]);
   this->chunk_length     = LE_16 (&chunk_header[2]);
@@ -493,7 +500,7 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
     read_len = io_read (io, this->s, ext_header, ext_header_len);
     if (read_len != ext_header_len) {
       lprintf ("extended header read failed. %d != %d\n", read_len, ext_header_len);
-      return 0;
+      return ERROR;
     }
   }
   
@@ -535,38 +542,43 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
 #endif
 
   this->chunk_length -= ext_header_len;
-  return 1;
+  return SUCCESS;
 }
 
 static int get_header (mms_io_t *io, mmsh_t *this) {
-  int len = 0;
+  int ret, len = 0;
 
   lprintf("get_header\n");
 
   this->asf_header_len = 0;
   this->asf_header_read = 0;
+  this->buf_size = 0;
 
   /* read chunk */
   while (1) {
-    if (get_chunk_header(io, this)) {
+    if ((ret = get_chunk_header(io, this)) == SUCCESS) {
       if (this->chunk_type == CHUNK_TYPE_ASF_HEADER) {
         if ((this->asf_header_len + this->chunk_length) > ASF_HEADER_SIZE) {
 	  lprintf ("mmsh: the asf header exceed %d bytes\n", ASF_HEADER_SIZE);
-          return 0;
+          return ERROR;
         } else {
 	  len = io_read(io, this->s, this->asf_header + this->asf_header_len,
 			this->chunk_length);
-          this->asf_header_len += len;
+          if (len > 0)
+            this->asf_header_len += len;
           if (len != this->chunk_length) {
-            return 0;
+            lprintf ("mmsh: asf header chunk read failed, %d != %d\n", len,
+                     this->chunk_length);
+            return ERROR;
           }
         }
       } else {
         break;
       }
     } else {
-      lprintf("get_chunk_header failed\n");
-      return 0;
+      if (this->asf_header_len == 0 || ret != EOS)
+        lprintf("mmsh: get_header failed to get chunk header\n");
+      return ret;
     }
   }
 
@@ -575,13 +587,15 @@ static int get_header (mms_io_t *io, mmsh_t *this) {
     len = io_read (io, this->s, this->buf, this->chunk_length);
 
     if (len != this->chunk_length) {
-      return 0;
+      lprintf ("mmsh: asf data chunk read failed, %d != %d\n", len,
+               this->chunk_length);
+      return ERROR;
     } else {
       /* check and 0 pad the first data chunk */
       if (this->chunk_length > this->packet_length) {
         lprintf ("mmsh: chunk_length(%d) > packet_length(%d)\n",
                  this->chunk_length, this->packet_length);
-        return 0;
+        return ERROR;
       }
 
       /* explicit padding with 0 */
@@ -591,11 +605,12 @@ static int get_header (mms_io_t *io, mmsh_t *this) {
 
       this->buf_size = this->packet_length;
 
-      return 1;
+      return SUCCESS;
     }
   } else {
     /* unexpected packet type */
-    return 0;
+    lprintf ("mmsh: unexpected chunk_type(0x%04x)\n", this->chunk_type);
+    return ERROR;
   }
 }
 
@@ -904,8 +919,10 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   if (!get_answer (io, this))
     goto fail;
 
-    
-  get_header(io, this);
+  /* Don't check for != SUCCESS as EOS is normal here too */    
+  if (get_header(io, this) == ERROR)
+    goto fail;
+
   interp_header(io, this);
   if (!this->packet_length || !this->num_stream_ids)
     goto fail;
@@ -1024,7 +1041,7 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   if (!get_answer (io, this))
     goto fail;
 
-  if (!get_header(io, this))
+  if (get_header(io, this) != SUCCESS)
     goto fail;
 
   interp_header(io, this);
@@ -1208,19 +1225,12 @@ fail:
   return NULL;
 }
 
-
-/*
- * returned value:
- *  0: error
- *  1: data packet read
- *  2: new header and data packet read
- */
 static int get_media_packet (mms_io_t *io, mmsh_t *this) {
-  int len = 0;
+  int ret, len = 0;
 
   lprintf("get_media_packet: this->packet_length: %d\n", this->packet_length);
 
-  if (get_chunk_header(io, this)) {
+  if (get_chunk_header(io, this) == SUCCESS) {
     switch (this->chunk_type) {
       case CHUNK_TYPE_END:
 	/* this->chunk_seq_number:
@@ -1228,11 +1238,11 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 	 *     1: a new stream follows
 	 */
 	if (this->chunk_seq_number == 0)
-	  return 0;
+	  return EOS;
 
         this->http_request_number = 1;
 	if (!mmsh_connect_int (io, this, 0, 0))
-	  return 0;
+	  return ERROR;
 
 	/* What todo with: current_pos ??
 	   Also our chunk_seq_numbers will probably restart from 0!
@@ -1242,7 +1252,7 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 
 	/* mmsh_connect_int reads the first data packet */
 	/* this->buf_size is set by mmsh_connect_int */
-	return 2;
+	return GOT_HEADER_N_DATA;
 
       case CHUNK_TYPE_DATA:
 	/* nothing to do */
@@ -1253,10 +1263,13 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 
 	if (this->chunk_length != 0) {
 	  /* that's strange, don't know what to do */
-	  return 0;
+	  lprintf("mmsh: non 0 sized reset chunk");
+	  return ERROR;
 	}
-	if (!get_header (io, this))
-	  return 0;
+	if ((ret = get_header (io, this)) != SUCCESS) {
+	  lprintf("mmsh: failed to get header after reset chunk\n");
+	  return ret;
+        }
 	interp_header(io, this);
 
 	/* What todo with: current_pos ??
@@ -1267,11 +1280,11 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 
 	/* get_header reads the first data packet */
 	/* this->buf_size is set by get_header */
-	return 2;
+	return GOT_HEADER_N_DATA;
 
       default:
-	lprintf ("mmsh: unexpected chunk type\n");
-        return 0;
+        lprintf ("mmsh: unexpected chunk_type(0x%04x)\n", this->chunk_type);
+        return ERROR;
     }
 
     len = io_read (io, this->s, this->buf, this->chunk_length);
@@ -1281,7 +1294,7 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
       if (this->chunk_length > this->packet_length) {
 	lprintf ("mmsh: chunk_length(%d) > packet_length(%d)\n",
 		 this->chunk_length, this->packet_length);
-	return 0;
+	return ERROR;
       }
 
       {
@@ -1299,13 +1312,17 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 	  this->buf_size = this->packet_length;
 	}
       }
-      return 1;
+      return SUCCESS;
     } else {
-      lprintf ("mmsh: read error, %d != %d\n", len, this->chunk_length);
-      return 0;
+      lprintf("mmsh: media packet read error, %d != %d\n", len,
+              this->chunk_length);
+      return ERROR;
     }
+  } else if (ret == EOS) {
+    return EOS;
   } else {
-    return 0;
+    lprintf("mmsh: get_media_packet failed to get chunk header\n");
+    return ret;
   }
 }
 
@@ -1355,15 +1372,20 @@ int mmsh_read (mms_io_t *io, mmsh_t *this, char *data, int len) {
       bytes_left = this->buf_size - this->buf_read;
 
       if (bytes_left == 0) {
-	int packet_type;
+	int ret;
 
 	this->buf_size=this ->buf_read = 0;
-	packet_type = get_media_packet (io, this);
+	ret = get_media_packet (io, this);
 
-	if (packet_type == 0) {
+	switch (ret) {
+	case SUCCESS:
+	  break;
+        case ERROR:
 	  lprintf ("mmsh: get_media_packet failed\n");
 	  return total;
-	} else if (packet_type == 2) {
+        case EOS:
+	  return total;
+        case GOT_HEADER_N_DATA:
 	  continue;
 	}
 	bytes_left = this->buf_size;
-- 
1.7.0

From df03d5ccc7ac40d3deb9afb9d6dccc215fc83cd1 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Mon, 8 Feb 2010 22:12:31 +0100
Subject: [PATCH 11/22] Silence mmsh debug spew

Remove some too verbose printfs and make the message formatting more
consistent (prefix everything with "mssh: "). While at it also move
the close in our connect function, so we don't close the socket
when trying the next host in the gethostaddr answer.
---
 src/mmsh.c |  147 ++++++++++++++++++++---------------------------------------
 1 files changed, 50 insertions(+), 97 deletions(-)

diff --git a/src/mmsh.c b/src/mmsh.c
index 9157c6d..ae1bbf8 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -229,22 +229,20 @@ static off_t fallback_io_read(void *data, int socket, char *buf, off_t num)
     ret = (off_t)read(socket, buf + len, num - len);
     if(ret == 0)
       break; /* EOS */
-    if(ret < 0)
+    if(ret < 0) {
+      lprintf("mmsh: read error @ len = %lld: %s\n", (long long int) len,
+              strerror(errno));
       switch(errno)
       {
 	  case EAGAIN:
-	    lprintf("len == %lld\n", (long long int) len);
-	    break;
+	    continue;
 	  default:
-	    lprintf("len == %lld\n", (long long int) len);
-	    perror(NULL);
 	    /* if already read something, return it, we will fail next time */
 	    return len ? len : ret; 
       }
+    }
     len += ret;
   }
-  lprintf("ret len == %lld\nnum == %lld\n", (long long int) len, (long long int) num);
-  lprintf("read\n");
   return len;
 }
 
@@ -261,18 +259,18 @@ static int fallback_io_tcp_connect(void *data, const char *host, int port)
   
   h = gethostbyname(host);
   if (h == NULL) {
-/*     fprintf(stderr, "unable to resolve host: %s\n", host); */
+    lprintf("mmsh: unable to resolve host: %s\n", host);
     return -1;
   }
 
   s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  
   if (s == -1) {
-/*     fprintf(stderr, "failed to create socket: %s", strerror(errno)); */
+    lprintf("mmsh: failed to create socket: %s\n", strerror(errno));
     return -1;
   }
 
   if (fcntl (s, F_SETFL, fcntl (s, F_GETFL) & ~O_NONBLOCK) == -1) {
-/*     _x_message(stream, XINE_MSG_CONNECTION_REFUSED, "can't put socket in non-blocking mode", strerror(errno), NULL); */
+    lprintf("mmsh: failed to set socket flags: %s\n", strerror(errno));
     return -1;
   }
 
@@ -286,15 +284,12 @@ static int fallback_io_tcp_connect(void *data, const char *host, int port)
     sin.sin_port   = htons(port);
     
     if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) ==-1 && errno != EINPROGRESS) {
-
-      /* FIXME: de-xine-ification */
-/*       _x_message(stream, XINE_MSG_CONNECTION_REFUSED, strerror(errno), NULL); */
-      close(s);
       continue;
     }
     
     return s;
   }
+  close(s);
   return -1;
 }
 
@@ -341,14 +336,13 @@ static int get_guid (unsigned char *buffer, int offset) {
   
   for (i = 1; i < GUID_END; i++) {
     if (!memcmp(&g, &guids[i].guid, sizeof(GUID))) {
-      lprintf ("GUID: %s\n", guids[i].name);
-
+      lprintf("mmsh: GUID: %s\n", guids[i].name);
       return i;
     }
   }
 
-  lprintf ("libmmsh: unknown GUID: 0x%x, 0x%x, 0x%x, "
-           "{ 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx }\n",
+  lprintf("mmsh: unknown GUID: 0x%x, 0x%x, 0x%x, "
+          "{ 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx }\n",
           g.Data1, g.Data2, g.Data3,
           g.Data4[0], g.Data4[1], g.Data4[2], g.Data4[3], 
           g.Data4[4], g.Data4[5], g.Data4[6], g.Data4[7]);
@@ -358,7 +352,7 @@ static int get_guid (unsigned char *buffer, int offset) {
 static int send_command (mms_io_t *io, mmsh_t *this, char *cmd)  {
   int length;
 
-  lprintf ("send_command:\n%s\n", cmd);
+  lprintf("mmsh: send_command:\n%s\n", cmd);
 
   length = strlen(cmd);
   if (io_write(io, this->s, cmd, length) != length) {
@@ -373,8 +367,6 @@ static int get_answer (mms_io_t *io, mmsh_t *this) {
   int done, len, linenum;
   char *features;
 
-  lprintf ("get_answer\n");
-
   done = 0; len = 0; linenum = 0;
   this->stream_type = MMSH_UNKNOWN;
 
@@ -397,7 +389,7 @@ static int get_answer (mms_io_t *io, mmsh_t *this) {
 
       linenum++;
       
-      lprintf ("answer: >%s<\n", this->buf);
+      lprintf("mmsh: answer: >%s<\n", this->buf);
 
       if (linenum == 1) {
         int httpver, httpsub, httpcode;
@@ -429,12 +421,12 @@ static int get_answer (mms_io_t *io, mmsh_t *this) {
           features = strstr(this->buf + 7, "features=");
           if (features) {
             if (strstr(features, "seekable")) {
-              lprintf("seekable stream\n");
+              lprintf("mmsh: seekable stream\n");
               this->stream_type = MMSH_SEEKABLE;
               this->seekable = 1;
             } else {
               if (strstr(features, "broadcast")) {
-                lprintf("live stream\n");
+                lprintf("mmsh: live stream\n");
                 this->stream_type = MMSH_LIVE;
                 this->seekable = 0;
               }
@@ -466,14 +458,12 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
   int read_len;
   int ext_header_len;
 
-  lprintf ("get_chunk_header\n");
-
   /* read chunk header */
   read_len = io_read(io, this->s, chunk_header, CHUNK_HEADER_LENGTH);
   if (read_len != CHUNK_HEADER_LENGTH) {
     if (read_len == 0)
       return EOS;
-    lprintf ("chunk header read failed, %d != %d\n", read_len, CHUNK_HEADER_LENGTH);
+    lprintf("mmsh: chunk header read failed, %d != %d\n", read_len, CHUNK_HEADER_LENGTH);
     return ERROR;
   }
   this->chunk_type       = LE_16 (&chunk_header[0]);
@@ -499,7 +489,7 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
   if (ext_header_len > 0) {
     read_len = io_read (io, this->s, ext_header, ext_header_len);
     if (read_len != ext_header_len) {
-      lprintf ("extended header read failed. %d != %d\n", read_len, ext_header_len);
+      lprintf("mmsh: extended header read failed. %d != %d\n", read_len, ext_header_len);
       return ERROR;
     }
   }
@@ -548,8 +538,6 @@ static int get_chunk_header (mms_io_t *io, mmsh_t *this) {
 static int get_header (mms_io_t *io, mmsh_t *this) {
   int ret, len = 0;
 
-  lprintf("get_header\n");
-
   this->asf_header_len = 0;
   this->asf_header_read = 0;
   this->buf_size = 0;
@@ -647,12 +635,12 @@ static void interp_stream_properties(mmsh_t *this, int i) {
   stream_id = flags & 0x7F;
   encrypted = flags >> 15;
 
-  lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
-      stream_id, type, encrypted);
+  lprintf("mmsh: stream object, stream id: %d, type: %d, encrypted: %d\n",
+          stream_id, type, encrypted);
 
   if (stream_id >= ASF_MAX_NUM_STREAMS ||
       this->num_stream_ids >= ASF_MAX_NUM_STREAMS) {
-    lprintf ("too many streams, skipping\n");
+    lprintf("mmsh: too many streams, skipping\n");
     return;
   }
 
@@ -665,8 +653,6 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
   int i;
 
-  lprintf ("interp_header, header_len=%d\n", this->asf_header_len);
-
   this->packet_length = 0;
   this->num_stream_ids = 0;
   this->asf_num_packets = 0;
@@ -702,8 +688,8 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
         this->time_len       = LE_64(this->asf_header + i + 64 - 24);
         //this->time_len       = LE_64(this->asf_header + i + 72 - 24);
         this->preroll        = LE_64(this->asf_header + i + 80 - 24);
-        lprintf ("file object, packet length = %d (%d)\n",
-		 this->packet_length, LE_32(this->asf_header + i + 96 - 24));
+        lprintf("mmsh: file object, packet length = %d (%d)\n",
+		this->packet_length, LE_32(this->asf_header + i + 96 - 24));
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
@@ -716,14 +702,9 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
           uint16_t stream_id;
           int j;
 
-	  lprintf ("stream bitrate properties\n");
-          lprintf ("streams %d\n", streams);
-
           for(j = 0; j < streams; j++) {
             stream_id = LE_16(this->asf_header + i + 2 + j * 6);
 
-            lprintf ("stream id %d\n", stream_id);
-
             this->bitrates[stream_id] = LE_32(this->asf_header + i + 4 + j * 6);
             this->bitrates_pos[stream_id] = i + 4 + j * 6;
 	    lprintf ("mmsh: stream id %d, bitrate %d\n", stream_id, this->bitrates[stream_id]);
@@ -736,7 +717,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
           int size = LE_32(this->asf_header + i + 18);
           int j = 22;
           int l;
-          lprintf("Extension header data size: %d\n", size);
+          lprintf("mmsh: Extension header data size: %d\n", size);
 
           while( (j+24) < length ) {
             guid = get_guid(this->asf_header, i + j);
@@ -754,10 +735,9 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                   int ext_j = 64;
                   int x;
 
-                  lprintf ("l: %d\n", l);
-                  lprintf ("Stream No: %d\n", stream_no);
-                  lprintf ("Name count: %d\n", name_count);
-                  lprintf ("ext_count: %d\n", ext_count);
+                  lprintf("mmsh: l: %d\n", l);
+                  lprintf("mmsh: Stream No: %d\n", stream_no);
+                  lprintf("mmsh: ext_count: %d\n", ext_count);
 
                   // Loop through the number of stream names
                   for(x=0; x<name_count; x++) {
@@ -770,8 +750,8 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                     stream_name_len = LE_16(this->asf_header + i + j + ext_j);
                     ext_j += stream_name_len + 2;
 
-                    lprintf ("Language id index: %d\n", lang_id_index);
-                    lprintf ("Stream name Len: %d\n", stream_name_len);
+                    lprintf("mmsh: Language id index: %d\n", lang_id_index);
+                    lprintf("mmsh: Stream name Len: %d\n", stream_name_len);
                   }
 
                   // Loop through the number of extension system info
@@ -781,7 +761,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                     ext_j += 4 + len;
                   }
 
-                  lprintf ("ext_j: %d\n", ext_j);
+                  lprintf("mmsh: ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
                   if( (ext_j+24) < l ) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
@@ -789,14 +769,11 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                       interp_stream_properties(this, i + j + ext_j + 24);
                     }
                   } else {
-                    lprintf ("Sorry, field not long enough\n");
+                    lprintf("mmsh: Sorry, field not long enough\n");
                   }
 
                 }
                 break;
-              default:
-                lprintf ("unknown object (%d)\n", guid);
-                break;
             }
 
             if( l > 24 ) {
@@ -811,13 +788,9 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
         this->asf_num_packets = LE_64(this->asf_header + i + 40 - 24);
         lprintf("mmsh: num_packets: %d\n", (int)this->asf_num_packets);
         break;
-
-      default:
-        lprintf ("unknown object\n");
-        break;
     }
 
-    lprintf ("length: %llu\n", (unsigned long long)length);
+    lprintf("mmsh: length: %llu\n", (unsigned long long)length);
 
     if (length > 24) {
       i += length - 24;
@@ -830,8 +803,6 @@ const static char *const mmsh_proto_s[] = { "mms", "mmsh", NULL };
 static int mmsh_valid_proto (char *proto) {
   int i = 0;
 
-  lprintf("mmsh_valid_proto\n");
-
   if (!proto)
     return 0;
 
@@ -855,12 +826,12 @@ static int mmsh_tcp_connect(mms_io_t *io, mmsh_t *this) {
   /* 
    * try to connect 
    */
-  lprintf("try to connect to %s on port %d \n", this->connect_host, this->connect_port);
+  lprintf("mmsh: try to connect to %s on port %d \n", this->connect_host, this->connect_port);
 
   this->s = io_connect (io, this->connect_host, this->connect_port);
 
   if (this->s == -1) {
-    lprintf ("mmsh: failed to connect '%s'\n", this->connect_host);
+    lprintf("mmsh: failed to connect '%s'\n", this->connect_host);
     return 1;
   }
 
@@ -876,7 +847,7 @@ static int mmsh_tcp_connect(mms_io_t *io, mmsh_t *this) {
     this->s = -1;
     return 1;
   }
-  lprintf ("connected\n");
+  lprintf("mmsh: connected\n");
 
   return 0;
 }
@@ -908,7 +879,7 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   this->num_stream_ids = 0;
 
   /* first request */
-  lprintf("first http request\n");
+  lprintf("mmsh: first http request\n");
   
   snprintf (this->str, SCRATCH_SIZE, mmsh_FirstRequest, this->uri,
             this->http_host, this->http_port, this->http_request_number++);
@@ -952,7 +923,7 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   if (bandwitdh_left < 0) {
     bandwitdh_left = 0;
   }
-  lprintf("bandwitdh %d, left %d\n", this->user_bandwidth, bandwitdh_left);
+  lprintf("mmsh: bandwitdh %d, left %d\n", this->user_bandwidth, bandwitdh_left);
 
   min_bw_left = bandwitdh_left;
   for (i = 0; i < this->num_stream_ids; i++) {
@@ -989,10 +960,10 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
     }
   }
 
-  lprintf("audio stream %d, video stream %d\n", audio_stream, video_stream);
+  lprintf("mmsh: audio stream %d, video stream %d\n", audio_stream, video_stream);
   
   /* second request */
-  lprintf("second http request\n");
+  lprintf("mmsh: second http request\n");
 
   if (mmsh_tcp_connect(io, this)) {
     return 0;
@@ -1010,7 +981,7 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
       size = snprintf(stream_selection + offset, sizeof(stream_selection) - offset,
                       "ffff:%d:0 ", this->stream_ids[i]);
     } else {
-      lprintf ("disabling stream %d\n", this->stream_ids[i]);
+      lprintf("mmsh: disabling stream %d\n", this->stream_ids[i]);
       size = snprintf(stream_selection + offset, sizeof(stream_selection) - offset,
                       "ffff:%d:2 ", this->stream_ids[i]);
     }
@@ -1036,8 +1007,6 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   if (!send_command (io, this, this->str))
     goto fail;
   
-  lprintf("before read \n");
-
   if (!get_answer (io, this))
     goto fail;
 
@@ -1061,8 +1030,7 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
 	  this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 2] = 0;
 	  this->asf_header[this->bitrates_pos[this->stream_ids[i]] + 3] = 0;
         } else {
-          lprintf("***LOG:*** -- "
-                  "libmms: attempt to write beyond asf header limit");
+          lprintf("mmsh: attempt to write beyond asf header limit");
         }
       }
     }
@@ -1124,7 +1092,7 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
   if (this->proxy_url) {
     proxy_uri = gnet_uri_new(this->proxy_url);
     if (!proxy_uri) {
-      lprintf("invalid proxy url\n");
+      lprintf("mmsh: invalid proxy url\n");
       goto fail;
     }
     if (! proxy_uri->port ) {
@@ -1133,7 +1101,7 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
   }
   uri = gnet_uri_new(this->url);
   if (!uri) {
-    lprintf ("invalid url\n");
+    lprintf("mmsh: invalid url\n");
     goto fail;
   }
   if (! uri->port ) {
@@ -1177,21 +1145,17 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
     uri = NULL;
   }
   if (!mmsh_valid_proto(this->proto)) {
-    lprintf ("unsupported protocol\n");
+    lprintf("mmsh: unsupported protocol\n");
     goto fail;
   }
 
   if (!mmsh_connect_int(io, this, 0, 0))
     goto fail;
 
-//  report_progress (stream, 100);
-
-  lprintf("mmsh_connect: passed\n" );
-
   return this;
 
 fail:
-  lprintf("mmsh_connect: failed\n" );
+  lprintf("mmsh: connect failed\n");
   if (proxy_uri)
     gnet_uri_delete(proxy_uri);
   if (uri)
@@ -1220,16 +1184,12 @@ fail:
     free(this->uri);
 
   free(this);
-
-  lprintf("mmsh_connect: failed return\n" );
   return NULL;
 }
 
 static int get_media_packet (mms_io_t *io, mmsh_t *this) {
   int ret, len = 0;
 
-  lprintf("get_media_packet: this->packet_length: %d\n", this->packet_length);
-
   if (get_chunk_header(io, this) == SUCCESS) {
     switch (this->chunk_type) {
       case CHUNK_TYPE_END:
@@ -1283,7 +1243,7 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 	return GOT_HEADER_N_DATA;
 
       default:
-        lprintf ("mmsh: unexpected chunk_type(0x%04x)\n", this->chunk_type);
+        lprintf("mmsh: unexpected chunk_type(0x%04x)\n", this->chunk_type);
         return ERROR;
     }
 
@@ -1292,8 +1252,8 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
     if (len == this->chunk_length) {
       /* explicit padding with 0 */
       if (this->chunk_length > this->packet_length) {
-	lprintf ("mmsh: chunk_length(%d) > packet_length(%d)\n",
-		 this->chunk_length, this->packet_length);
+	lprintf("mmsh: chunk_length(%d) > packet_length(%d)\n",
+		this->chunk_length, this->packet_length);
 	return ERROR;
       }
 
@@ -1329,8 +1289,6 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 int mmsh_peek_header (mmsh_t *this, char *data, int maxsize) {
   int len;
 
-  lprintf("mmsh_peek_header\n");
-
   len = (this->asf_header_len < maxsize) ? this->asf_header_len : maxsize;
 
   memcpy(data, this->asf_header, len);
@@ -1342,8 +1300,6 @@ int mmsh_read (mms_io_t *io, mmsh_t *this, char *data, int len) {
 
   total = 0;
 
-  lprintf ("mmsh_read: len: %d\n", len);
-
   /* Check if the stream didn't get closed because of previous errors */
   if (this->s == -1)
     return total;
@@ -1507,14 +1463,14 @@ off_t mmsh_seek (mms_io_t *io, mmsh_t *this, off_t offset, int origin) {
       (this->asf_header_len + dest_packet_seq*this->packet_length);
     this->current_pos = dest;
   } else {
-    lprintf("Seek failed, wanted packet: %d, got packet: %d\n",
+    lprintf("mmsh: Seek failed, wanted packet: %d, got packet: %d\n",
       (int)dest_packet_seq, (int)this->chunk_seq_number);
     this->buf_read = 0;
     this->current_pos = this->asf_header_len + this->chunk_seq_number *
       this->packet_length;
   }
 
-  lprintf("current_pos after seek to %d: %d (buf_read %d)\n",
+  lprintf("mmsh: current_pos after seek to %d: %d (buf_read %d)\n",
     (int)dest, (int)this->current_pos, (int)this->buf_read);
 
   return this->current_pos;
@@ -1556,9 +1512,6 @@ int mmsh_time_seek (mms_io_t *io, mmsh_t *this, double time_sec) {
 }
 
 void mmsh_close (mmsh_t *this) {
-
-  lprintf("mmsh_close\n");
-
   if (this->s != -1)
     close(this->s);
   if (this->url)
-- 
1.7.0

From 6aad559107af96a29efed97564446bec33ef23e1 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 12:53:17 +0100
Subject: [PATCH 12/22] mms: Use relative path for open file command

On some servers the open file command will fail when permission denied
when the path passed to open file starts with a /, this has been seen on
mms url's with query parameters which include a hash param. Probably the
adding of the / in front is making the hash fail.
---
 src/mms.c  |    2 +-
 src/mmsh.c |    4 ++--
 src/uri.c  |    7 +++++--
 src/uri.h  |    2 +-
 4 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 8c69255..88576d8 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1179,7 +1179,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   this->host = uri->hostname;
   this->port = uri->port;
   this->password = uri->passwd;
-  this->uri = gnet_mms_helper(uri);
+  this->uri = gnet_mms_helper(uri, 0);
 
   if(!this->uri)
 	goto fail;
diff --git a/src/mmsh.c b/src/mmsh.c
index ae1bbf8..fcd4e8c 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -1119,7 +1119,7 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
     this->host_user = (uri->user) ? strdup(uri->user) : NULL;
     this->host_password = (uri->passwd) ? strdup(uri->passwd) : NULL;
     gnet_uri_set_scheme(uri,"http");
-    this->uri = gnet_mms_helper(uri);
+    this->uri = gnet_mms_helper(uri, 1);
   } else {
     this->proto = (uri->scheme) ? strdup(uri->scheme) : NULL;
     this->connect_host = (uri->hostname) ? strdup(uri->hostname) : NULL;
@@ -1130,7 +1130,7 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
     this->proxy_password = NULL;
     this->host_user =(uri->user) ?  strdup(uri->user) : NULL;
     this->host_password = (uri->passwd) ? strdup(uri->passwd) : NULL;
-    this->uri = gnet_mms_helper(uri);
+    this->uri = gnet_mms_helper(uri, 1);
   }
 
   if(!this->uri)
diff --git a/src/uri.c b/src/uri.c
index 36710a5..84f3191 100644
--- a/src/uri.c
+++ b/src/uri.c
@@ -867,7 +867,7 @@ gnet_uri_set_fragment (GURI* uri, const char* fragment)
  *
  **/
 
-char* gnet_mms_helper(const GURI* uri)
+char* gnet_mms_helper(const GURI* uri, int make_absolute)
 {
       size_t len = 0;
       char *ret, *tmp = NULL;
@@ -888,7 +888,10 @@ char* gnet_mms_helper(const GURI* uri)
       if (!(ret = (char *) malloc(len + 2)))
           return NULL;
 
-      strcpy(ret, "/");
+      if (make_absolute)
+          strcpy(ret, "/");
+      else
+          ret[0] = 0;
 
       /* Copy the optional path */
       if (tmp)
diff --git a/src/uri.h b/src/uri.h
index c7a93ed..2c89938 100644
--- a/src/uri.h
+++ b/src/uri.h
@@ -85,7 +85,7 @@ void 	  gnet_uri_set_path	(GURI* uri, const char* path);
 void 	  gnet_uri_set_query 	(GURI* uri, const char* query);
 void 	  gnet_uri_set_fragment (GURI* uri, const char* fragment);
 
-char*     gnet_mms_helper(const GURI* uri);
+char*     gnet_mms_helper(const GURI* uri, int make_absolute);
 
 #ifdef __cplusplus
 }
-- 
1.7.0

From 11d85a5a21c82b54f5da1948ef13c590362d30db Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 12:58:10 +0100
Subject: [PATCH 13/22] mms: Free GURI when we are done with it

---
 src/mms.c |   38 +++++++++++++-------------------------
 1 files changed, 13 insertions(+), 25 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 88576d8..9cfa83d 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -117,6 +117,7 @@ struct mms_s {
   int           s;
   
   /* url parsing */
+  GURI         *guri;
   char         *url;
   char         *proto;
   char         *host;
@@ -1138,7 +1139,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 #endif
   mms_t  *this;
   int     res;
-  GURI   *uri;
   
   if (!url)
     return NULL;
@@ -1169,17 +1169,17 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   /* FIXME de-xine-ification */
 /*   report_progress (stream, 0); */
   
-  uri = gnet_uri_new(this->url);
-  if(!uri) {
+  this->guri = gnet_uri_new(this->url);
+  if(!this->guri) {
     lprintf ("invalid url\n");
     goto fail;
   }
-  this->proto = uri->scheme;
-  this->user = uri->user;
-  this->host = uri->hostname;
-  this->port = uri->port;
-  this->password = uri->passwd;
-  this->uri = gnet_mms_helper(uri, 0);
+  this->proto = this->guri->scheme;
+  this->user = this->guri->user;
+  this->host = this->guri->hostname;
+  this->port = this->guri->port;
+  this->password = this->guri->passwd;
+  this->uri = gnet_mms_helper(this->guri, 0);
 
   if(!this->uri)
 	goto fail;
@@ -1398,14 +1398,8 @@ fail:
     close (this->s);
   if (this->url)
     free(this->url);
-  if (this->proto)
-    free(this->proto);
-  if (this->host)
-    free(this->host);
-  if (this->user)
-    free(this->user);
-  if (this->password)
-    free(this->password);
+  if (this->guri)
+    gnet_uri_delete(this->guri);
   if (this->uri)
     free(this->uri);
 
@@ -1921,14 +1915,8 @@ void mms_close (mms_t *this) {
     close (this->s);
   if (this->url)
     free(this->url);
-  if (this->proto)
-    free(this->proto);
-  if (this->host)
-    free(this->host);
-  if (this->user)
-    free(this->user);
-  if (this->password)
-    free(this->password);
+  if (this->guri)
+    gnet_uri_delete(this->guri);
   if (this->uri)
     free(this->uri);
 
-- 
1.7.0

From 735542772eaa40972be81f6096aac07d03bb1a7a Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 14:12:09 +0100
Subject: [PATCH 14/22] Remove the 24 bytes offset from i when parsing asf headers

The length field in asf headers includes the 24 bytes for the guid +
length of the header itself. Instead of adding / removing this everywhere
(which is esp. confusing when doing out of bounds checking), change i to
point to the start of the header instead of to the start of the
header data.
---
 src/mms.c  |   40 ++++++++++++++++++----------------------
 src/mmsh.c |   40 +++++++++++++++++-----------------------
 2 files changed, 35 insertions(+), 45 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 9cfa83d..759196d 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -770,43 +770,42 @@ static void interp_asf_header (mms_t *this) {
    */
    
   i = 30;
-  while (i < this->asf_header_len) {
+  while ((i + 24) <= this->asf_header_len) {
     
     int guid;
     uint64_t length;
 
     guid = get_guid(this->asf_header, i);
-    i += 16;
-        
-    length = LE_64(this->asf_header + i);
-    i += 8;
+    length = LE_64(this->asf_header + i + 16);
+
+    if ((i + length) > this->asf_header_len) return;
 
     switch (guid) {
     
       case GUID_ASF_FILE_PROPERTIES:
 
-        this->asf_packet_len = LE_32(this->asf_header + i + 92 - 24);
+        this->asf_packet_len = LE_32(this->asf_header + i + 92);
         if (this->asf_packet_len > BUF_SIZE) {
           this->asf_packet_len = 0;
           lprintf( "***LOG:*** -- "
                    "libmms: asf packet len too large\n");
           break;
         }
-        this->file_len       = LE_64(this->asf_header + i + 40 - 24);
-        this->time_len       = LE_64(this->asf_header + i + 64 - 24);
-        //this->time_len       = LE_64(this->asf_header + i + 72 - 24);
-        this->preroll        = LE_64(this->asf_header + i + 80 - 24);
+        this->file_len       = LE_64(this->asf_header + i + 40);
+        this->time_len       = LE_64(this->asf_header + i + 64);
+        //this->time_len       = LE_64(this->asf_header + i + 72);
+        this->preroll        = LE_64(this->asf_header + i + 80);
         lprintf ("file object, packet length = %d (%d)\n",
-                 this->asf_packet_len, LE_32(this->asf_header + i + 96 - 24));
+                 this->asf_packet_len, LE_32(this->asf_header + i + 96));
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
-        interp_stream_properties(this, i);
+        interp_stream_properties(this, i + 24);
         break;
 
       case GUID_ASF_STREAM_BITRATE_PROPERTIES:
         {
-          uint16_t streams = LE_16(this->asf_header + i);
+          uint16_t streams = LE_16(this->asf_header + i + 24);
           uint16_t stream_id;
           int j;
 
@@ -815,15 +814,15 @@ static void interp_asf_header (mms_t *this) {
 
           for(j = 0; j < streams; j++) {
             int stream_index;
-            stream_id = LE_16(this->asf_header + i + 2 + j * 6);
+            stream_id = LE_16(this->asf_header + i + 24 + 2 + j * 6);
             lprintf ("stream id %d\n", stream_id);
             for(stream_index = 0; stream_index < this->num_stream_ids; stream_index++) {
               if (this->streams[stream_index].stream_id == stream_id)
                 break;
             }
             if (stream_index < this->num_stream_ids) {
-              this->streams[stream_index].bitrate = LE_32(this->asf_header + i + 4 + j * 6);
-              this->streams[stream_index].bitrate_pos = i + 4 + j * 6;
+              this->streams[stream_index].bitrate = LE_32(this->asf_header + i + 24 + 4 + j * 6);
+              this->streams[stream_index].bitrate_pos = i + 24 + 4 + j * 6;
               lprintf ("stream id %d, bitrate %d\n", stream_id, 
                      this->streams[stream_index].bitrate);
             }
@@ -833,8 +832,8 @@ static void interp_asf_header (mms_t *this) {
     
       case GUID_ASF_HEADER_EXTENSION:
         {
-          int size = LE_32(this->asf_header + i + 18);
-          int j = 22;
+          int size = LE_32(this->asf_header + i + 24 + 18);
+          int j = 24 + 18 + 4;
           int l;
           lprintf("Extension header data size: %d\n", size);
 
@@ -916,10 +915,7 @@ static void interp_asf_header (mms_t *this) {
     }
 
     lprintf ("length: %llu\n", (unsigned long long)length);
-
-    if (length > 24) {
-      i += length - 24;
-    }
+    i += length;
   }
 }
 
diff --git a/src/mmsh.c b/src/mmsh.c
index fcd4e8c..5ea82e2 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -662,51 +662,48 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
    */
 
   i = 30;
-  while ((i + 24) < this->asf_header_len) {
+  while ((i + 24) <= this->asf_header_len) {
 
     int guid;
     uint64_t length;
 
     guid = get_guid(this->asf_header, i);
-    i += 16;
+    length = LE_64(this->asf_header + i + 16);
 
-    length = LE_64(this->asf_header + i);
-    i += 8;
-
-    if ((i + length) >= this->asf_header_len) return;
+    if ((i + length) > this->asf_header_len) return;
 
     switch (guid) {
 
       case GUID_ASF_FILE_PROPERTIES:
 
-        this->packet_length = LE_32(this->asf_header + i + 92 - 24);
+        this->packet_length = LE_32(this->asf_header + i + 92);
         if (this->packet_length > CHUNK_SIZE) {
           this->packet_length = 0;
           break;
         }
-        this->file_length   = LE_64(this->asf_header + i + 40 - 24);
-        this->time_len       = LE_64(this->asf_header + i + 64 - 24);
-        //this->time_len       = LE_64(this->asf_header + i + 72 - 24);
-        this->preroll        = LE_64(this->asf_header + i + 80 - 24);
+        this->file_length   = LE_64(this->asf_header + i + 40);
+        this->time_len       = LE_64(this->asf_header + i + 64);
+        //this->time_len       = LE_64(this->asf_header + i + 72);
+        this->preroll        = LE_64(this->asf_header + i + 80);
         lprintf("mmsh: file object, packet length = %d (%d)\n",
-		this->packet_length, LE_32(this->asf_header + i + 96 - 24));
+		this->packet_length, LE_32(this->asf_header + i + 96));
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
-        interp_stream_properties(this, i);
+        interp_stream_properties(this, i + 24);
         break;
 
       case GUID_ASF_STREAM_BITRATE_PROPERTIES:
         {
-          uint16_t streams = LE_16(this->asf_header + i);
+          uint16_t streams = LE_16(this->asf_header + i + 24);
           uint16_t stream_id;
           int j;
 
           for(j = 0; j < streams; j++) {
-            stream_id = LE_16(this->asf_header + i + 2 + j * 6);
+            stream_id = LE_16(this->asf_header + i + 24 + 2 + j * 6);
 
-            this->bitrates[stream_id] = LE_32(this->asf_header + i + 4 + j * 6);
-            this->bitrates_pos[stream_id] = i + 4 + j * 6;
+            this->bitrates[stream_id] = LE_32(this->asf_header + i + 24 + 4 + j * 6);
+            this->bitrates_pos[stream_id] = i + 24 + 4 + j * 6;
 	    lprintf ("mmsh: stream id %d, bitrate %d\n", stream_id, this->bitrates[stream_id]);
           }
         }
@@ -714,8 +711,8 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
       case GUID_ASF_HEADER_EXTENSION:
         {
-          int size = LE_32(this->asf_header + i + 18);
-          int j = 22;
+          int size = LE_32(this->asf_header + i + 24 + 18);
+          int j = 24 + 18 + 4;
           int l;
           lprintf("mmsh: Extension header data size: %d\n", size);
 
@@ -791,10 +788,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
     }
 
     lprintf("mmsh: length: %llu\n", (unsigned long long)length);
-
-    if (length > 24) {
-      i += length - 24;
-    }
+    i += length;
   }
 }
 
-- 
1.7.0

From 6edcd0bb99e789fe1745eaca0039ee8d198e6aae Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 14:18:35 +0100
Subject: [PATCH 15/22] Remove the 24 bytes offset from j when parsing ext asf headers

The length field in asf headers includes the 24 bytes for the guid +
length of the header itself. Instead of adding / removing this everywhere
(which is esp. confusing when doing out of bounds checking), change j to
point to the start of the header instead of to the start of the
header data.
---
 src/mms.c  |   20 +++++++-------------
 src/mmsh.c |   21 +++++++--------------
 2 files changed, 14 insertions(+), 27 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 759196d..6850e99 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -839,18 +839,15 @@ static void interp_asf_header (mms_t *this) {
 
           while( (j+24) < length ) {
             guid = get_guid(this->asf_header, i + j);
-            j += 16;
-
-            l = LE_64(this->asf_header + i + j);
-            j += 8;
+            l = LE_64(this->asf_header + i + j + 16);
 
             switch(guid) {
               case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
                 {
-                  int stream_no = LE_16(this->asf_header + i + j + 48);
-                  int name_count = LE_16(this->asf_header + i + j + 60);
-                  int ext_count = LE_16(this->asf_header + i + j + 62);
-                  int ext_j = 64;
+                  int stream_no = LE_16(this->asf_header + i + j + 24 + 48);
+                  int name_count = LE_16(this->asf_header + i + j + 24 + 60);
+                  int ext_count = LE_16(this->asf_header + i + j + 24 + 62);
+                  int ext_j = 24 + 64;
                   int x;
 
                   lprintf ("l: %d\n", l);
@@ -882,7 +879,7 @@ static void interp_asf_header (mms_t *this) {
 
                   lprintf ("ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
-                  if( (ext_j+24) < l ) {
+                  if( (ext_j) < l ) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
                     if( guid == GUID_ASF_STREAM_PROPERTIES ) {
                       interp_stream_properties(this, i + j + ext_j + 24);
@@ -897,10 +894,7 @@ static void interp_asf_header (mms_t *this) {
                 lprintf ("unknown object (%d)\n", guid);
                 break;
             }
-
-            if( l > 24 ) {
-              j += l-24;
-            }
+            j += l;
           }
         }
         break;
diff --git a/src/mmsh.c b/src/mmsh.c
index 5ea82e2..a3a93e1 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -718,18 +718,15 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
           while( (j+24) < length ) {
             guid = get_guid(this->asf_header, i + j);
-            j += 16;
-
-            l = LE_64(this->asf_header + i + j);
-            j += 8;
+            l = LE_64(this->asf_header + i + j + 16);
 
             switch(guid) {
               case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
                 {
-                  int stream_no = LE_16(this->asf_header + i + j + 48);
-                  int name_count = LE_16(this->asf_header + i + j + 60);
-                  int ext_count = LE_16(this->asf_header + i + j + 62);
-                  int ext_j = 64;
+                  int stream_no = LE_16(this->asf_header + i + j + 24 + 48);
+                  int name_count = LE_16(this->asf_header + i + j + 24 + 60);
+                  int ext_count = LE_16(this->asf_header + i + j + 24 + 62);
+                  int ext_j = 24 + 64;
                   int x;
 
                   lprintf("mmsh: l: %d\n", l);
@@ -760,7 +757,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
                   lprintf("mmsh: ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
-                  if( (ext_j+24) < l ) {
+                  if( (ext_j) < l ) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
                     if( guid == GUID_ASF_STREAM_PROPERTIES ) {
                       interp_stream_properties(this, i + j + ext_j + 24);
@@ -772,12 +769,8 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                 }
                 break;
             }
-
-            if( l > 24 ) {
-              j += l-24;
-            }
+            j += l;
           }
-
         }
         break;
 
-- 
1.7.0

From 7d3f9f26bba8376a4f3e46de7da4d625f92d382a Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 22:02:59 +0100
Subject: [PATCH 16/22] Add out of bounds checking to extension header parsing

---
 src/mms.c  |   29 +++++++++++++++--------------
 src/mmsh.c |   26 +++++++++++++++-----------
 2 files changed, 30 insertions(+), 25 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 6850e99..015aa14 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -832,18 +832,23 @@ static void interp_asf_header (mms_t *this) {
     
       case GUID_ASF_HEADER_EXTENSION:
         {
+          if ((24 + 18 + 4) > length)
+            break;
+
           int size = LE_32(this->asf_header + i + 24 + 18);
           int j = 24 + 18 + 4;
           int l;
           lprintf("Extension header data size: %d\n", size);
 
-          while( (j+24) < length ) {
+          while ((j + 24) <= length) {
             guid = get_guid(this->asf_header, i + j);
             l = LE_64(this->asf_header + i + j + 16);
 
-            switch(guid) {
-              case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
-                {
+            if ((j + l) > length)
+              break;
+
+            if (guid == GUID_ASF_EXTENDED_STREAM_PROPERTIES &&
+                (24 + 64) <= l) {
                   int stream_no = LE_16(this->asf_header + i + j + 24 + 48);
                   int name_count = LE_16(this->asf_header + i + j + 24 + 60);
                   int ext_count = LE_16(this->asf_header + i + j + 24 + 62);
@@ -856,7 +861,7 @@ static void interp_asf_header (mms_t *this) {
                   lprintf ("ext_count: %d\n", ext_count);
 
                   // Loop through the number of stream names
-                  for(x=0; x<name_count; x++) {
+                  for (x = 0; x < name_count && (ext_j + 4) <= l; x++) {
                     int lang_id_index;
                     int stream_name_len;
 
@@ -871,7 +876,7 @@ static void interp_asf_header (mms_t *this) {
                   }
 
                   // Loop through the number of extension system info
-                  for(x=0; x<ext_count; x++) {
+                  for (x = 0; x < ext_count && (ext_j + 22) <= l; x++) {
                     ext_j += 18;
                     int len = LE_16(this->asf_header + i + j + ext_j);
                     ext_j += 4 + len;
@@ -879,20 +884,16 @@ static void interp_asf_header (mms_t *this) {
 
                   lprintf ("ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
-                  if( (ext_j) < l ) {
+                  if ((ext_j + 24) <= l) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
-                    if( guid == GUID_ASF_STREAM_PROPERTIES ) {
+                    int len = LE_64(this->asf_header + i + j + ext_j + 16);
+                    if (guid == GUID_ASF_STREAM_PROPERTIES &&
+                        (ext_j + len) <= l) {
                       interp_stream_properties(this, i + j + ext_j + 24);
                     }
                   } else {
                     lprintf ("Sorry, field not long enough\n");
                   }
-
-                }
-                break;
-              default:
-                lprintf ("unknown object (%d)\n", guid);
-                break;
             }
             j += l;
           }
diff --git a/src/mmsh.c b/src/mmsh.c
index a3a93e1..5ee348e 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -711,18 +711,23 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
       case GUID_ASF_HEADER_EXTENSION:
         {
+          if ((24 + 18 + 4) > length)
+            break;
+
           int size = LE_32(this->asf_header + i + 24 + 18);
           int j = 24 + 18 + 4;
           int l;
           lprintf("mmsh: Extension header data size: %d\n", size);
 
-          while( (j+24) < length ) {
+          while ((j + 24) <= length) {
             guid = get_guid(this->asf_header, i + j);
             l = LE_64(this->asf_header + i + j + 16);
 
-            switch(guid) {
-              case GUID_ASF_EXTENDED_STREAM_PROPERTIES:
-                {
+            if ((j + l) > length)
+              break;
+
+            if (guid == GUID_ASF_EXTENDED_STREAM_PROPERTIES &&
+                (24 + 64) <= l) {
                   int stream_no = LE_16(this->asf_header + i + j + 24 + 48);
                   int name_count = LE_16(this->asf_header + i + j + 24 + 60);
                   int ext_count = LE_16(this->asf_header + i + j + 24 + 62);
@@ -734,7 +739,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                   lprintf("mmsh: ext_count: %d\n", ext_count);
 
                   // Loop through the number of stream names
-                  for(x=0; x<name_count; x++) {
+                  for (x = 0; x < name_count && (ext_j + 4) <= l; x++) {
                     int lang_id_index;
                     int stream_name_len;
 
@@ -749,7 +754,7 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
                   }
 
                   // Loop through the number of extension system info
-                  for(x=0; x<ext_count; x++) {
+                  for (x = 0; x < ext_count && (ext_j + 22) <= l; x++) {
                     ext_j += 18;
                     int len = LE_16(this->asf_header + i + j + ext_j);
                     ext_j += 4 + len;
@@ -757,17 +762,16 @@ static void interp_header (mms_io_t *io, mmsh_t *this) {
 
                   lprintf("mmsh: ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
-                  if( (ext_j) < l ) {
+                  if ((ext_j + 24) <= l) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
-                    if( guid == GUID_ASF_STREAM_PROPERTIES ) {
+                    int len = LE_64(this->asf_header + i + j + ext_j + 16);
+                    if (guid == GUID_ASF_STREAM_PROPERTIES &&
+                        (ext_j + len) <= l) {
                       interp_stream_properties(this, i + j + ext_j + 24);
                     }
                   } else {
                     lprintf("mmsh: Sorry, field not long enough\n");
                   }
-
-                }
-                break;
             }
             j += l;
           }
-- 
1.7.0

From c82568e52cb62b2381b20b3f1533f6689c6237b7 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 22:21:24 +0100
Subject: [PATCH 17/22] mms: Check status field of answers to our commands

---
 src/mms.c |   49 ++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 48 insertions(+), 1 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 015aa14..10d79ba 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -998,6 +998,18 @@ static void mms_gen_guid(char guid[]) {
   guid[36] = '\0';
 }
 
+const char *status_to_string(int status)
+{
+  switch (status) {
+  case 0x80070003:
+    return "Path not found";
+  case 0x80070005:
+    return "Access Denied";
+  default:
+    return "Unknown";
+  }
+}
+
 /*
  * return 0 on error
  */
@@ -1114,6 +1126,13 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
 	     "libmms: unexpected response: %02x (0x21)\n", res);
   }
 
+  res = LE_32(this->buf + 40);
+  if (res != 0) {
+    lprintf("mms: error answer 0x21 status: %08x (%s)\n",
+            res, status_to_string(res));
+    return 0;
+  }
+
   return 1;
 }
 
@@ -1214,7 +1233,14 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     lprintf("answer: %d\n", res);
     goto fail;
   }
-  
+
+  res = LE_32(this->buf + 40);
+  if (res != 0) {
+    lprintf("mms: error answer 0x01 status: %08x (%s)\n",
+            res, status_to_string(res));
+    goto fail;
+  }
+
   /* FIXME de-xine-ification */
 /*   report_progress (stream, 40); */
 
@@ -1246,6 +1272,13 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
       goto fail;
   }
 
+  res = LE_32(this->buf + 40);
+  if (res != 0) {
+    lprintf("mms: error answer 0x02 status: %08x (%s)\n",
+            res, status_to_string(res));
+    goto fail;
+  }
+
   /* FIXME de-xine-ification */
 /*   report_progress (stream, 50); */
 
@@ -1297,6 +1330,13 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
       goto fail;
   }
 
+  res = LE_32(this->buf + 40);
+  if (res != 0) {
+    lprintf("mms: error answer 0x06 status: %08x (%s)\n",
+            res, status_to_string(res));
+    goto fail;
+  }
+
   /* FIXME de-xine-ification */
 /*   report_progress (stream, 60); */
 
@@ -1330,6 +1370,13 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     goto fail;
   }
 
+  res = LE_32(this->buf + 40);
+  if (res != 0) {
+    lprintf("mms: error answer 0x11 status: %08x (%s)\n",
+            res, status_to_string(res));
+    goto fail;
+  }
+
   this->num_stream_ids = 0;
 
   if (!get_asf_header (io, this))
-- 
1.7.0

From 57e4b91268a1ffb2ec59317de823881cba007a70 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 22:43:51 +0100
Subject: [PATCH 18/22] mms: improve spec compliance for command 0x15

Thanks to MS releasing docs we can now check we are following the spec,
this brings us inline with the spec wrt command 0x15.
---
 src/mms.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 10d79ba..22e2a67 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1149,6 +1149,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 #endif
   mms_t  *this;
   int     res;
+  uint32_t openid;
   
   if (!url)
     return NULL;
@@ -1307,13 +1308,14 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
       {
         int xx, yy;
         /* no authentication required */
+        openid = LE_32(this->buf + 48);
       
         /* Warning: sdp is not right here */
         xx = this->buf[62];
         yy = this->buf[63];
         this->live_flag = ((xx == 0) && ((yy & 0xf) == 2));
         this->seekable = !this->live_flag;
-        lprintf("live: live_flag=%d, xx=%d, yy=%d\n", this->live_flag, xx, yy);
+        lprintf("mms: openid=%d, live: live_flag=%d, xx=%d, yy=%d\n", openid, this->live_flag, xx, yy);
       }
       break;
     case 0x1A:
@@ -1346,7 +1348,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     mms_buffer_t command_buffer;
     mms_buffer_init(&command_buffer, this->scmd_body);
     mms_buffer_put_32 (&command_buffer, 0x00000000);                  /* ?? */
-    mms_buffer_put_32 (&command_buffer, 0x00800000);                  /* ?? */
+    mms_buffer_put_32 (&command_buffer, 0x00008000);                  /* ?? */
     mms_buffer_put_32 (&command_buffer, 0xFFFFFFFF);                  /* ?? */
     mms_buffer_put_32 (&command_buffer, 0x00000000);                  /* ?? */
     mms_buffer_put_32 (&command_buffer, 0x00000000);                  /* ?? */
@@ -1355,7 +1357,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     mms_buffer_put_32 (&command_buffer, 0x40AC2000);                  /* ?? */
     mms_buffer_put_32 (&command_buffer, ASF_HEADER_PACKET_ID_TYPE);   /* Header Packet ID type */
     mms_buffer_put_32 (&command_buffer, 0x00000000);                  /* ?? */
-    if (!send_command (io, this, 0x15, 1, 0, command_buffer.pos)) {
+    if (!send_command (io, this, 0x15, openid, 0, command_buffer.pos)) {
   /* FIXME: de-xine-ification */
       lprintf ( "***LOG:*** -- "
 	       "libmms: failed to send command 0x15\n");
-- 
1.7.0

From f24d58b9bfe71f10cf6ca9acba9502b1e3899bd9 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Sun, 14 Feb 2010 23:53:26 +0100
Subject: [PATCH 19/22] mms: cleanup debug spew

* Remove some to verbose debug message
* Prefix all remaining messages with "mms: "
* While at it fix some error propagation issues
---
 src/mms.c |  289 ++++++++++++++++++++-----------------------------------------
 1 files changed, 95 insertions(+), 194 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 22e2a67..a50c7d9 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -22,10 +22,6 @@
  * MMS over TCP protocol
  *   based on work from major mms
  *   utility functions to handle communication with an mms server
- *
- * TODO:
- *   error messages
- *   enable seeking !
  */
 
 #ifdef HAVE_CONFIG_H
@@ -185,21 +181,20 @@ static off_t fallback_io_read(void *data, int socket, char *buf, off_t num)
     ret = (off_t)read(socket, buf + len, num - len);
     if(ret == 0)
       break; /* EOF */
-    if(ret < 0)
+    if(ret < 0) {
+      lprintf("mms: read error @ len = %lld: %s\n", (long long int) len,
+              strerror(errno));
       switch(errno)
       {
 	  case EAGAIN:
-	    lprintf("len == %lld\n", (long long int) len);
-	    break;
+	    continue;
 	  default:
-	    lprintf("len == %lld\n", (long long int) len);
-	    perror(NULL);
 	    /* if already read something, return it, we will fail next time */
 	    return len ? len : ret; 
       }
+    }
     len += ret;
   }
-  lprintf("ret len == %lld\nnum == %lld\n", (long long int) len, (long long int) num);
   return len;
 }
 
@@ -216,18 +211,18 @@ static int fallback_io_tcp_connect(void *data, const char *host, int port)
   
   h = gethostbyname(host);
   if (h == NULL) {
-/*     fprintf(stderr, "unable to resolve host: %s\n", host); */
+    lprintf("mms: unable to resolve host: %s\n", host);
     return -1;
   }
 
   s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  
   if (s == -1) {
-/*     fprintf(stderr, "failed to create socket: %s", strerror(errno)); */
+    lprintf("mms: failed to create socket: %s\n", strerror(errno));
     return -1;
   }
 
   if (fcntl (s, F_SETFL, fcntl (s, F_GETFL) & ~O_NONBLOCK) == -1) {
-/*     _x_message(stream, XINE_MSG_CONNECTION_REFUSED, "can't put socket in non-blocking mode", strerror(errno), NULL); */
+    lprintf("mms: failed to set socket flags: %s\n", strerror(errno));
     return -1;
   }
 
@@ -241,15 +236,12 @@ static int fallback_io_tcp_connect(void *data, const char *host, int port)
     sin.sin_port   = htons(port);
     
     if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) ==-1 && errno != EINPROGRESS) {
-
-      /* FIXME: de-xine-ification */
-/*       _x_message(stream, XINE_MSG_CONNECTION_REFUSED, strerror(errno), NULL); */
-      close(s);
       continue;
     }
     
     return s;
   }
+  close(s);
   return -1;
 }
 
@@ -373,12 +365,12 @@ static int get_guid (unsigned char *buffer, int offset) {
   
   for (i = 1; i < GUID_END; i++) {
     if (!memcmp(&g, &guids[i].guid, sizeof(GUID))) {
-      lprintf("GUID: %s\n", guids[i].name);
+      lprintf("mms: GUID: %s\n", guids[i].name);
       return i;
     }
   }
   
-  lprintf("unknown GUID: 0x%x, 0x%x, 0x%x, "
+  lprintf("mms: unknown GUID: 0x%x, 0x%x, 0x%x, "
 	   "{ 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx, 0x%hx }\n",
 	   g.Data1, g.Data2, g.Data3,
 	   g.Data4[0], g.Data4[1], g.Data4[2], g.Data4[3], 
@@ -548,10 +540,10 @@ static int get_packet_header (mms_io_t *io, mms_t *this, mms_packet_header_t *he
     
     header->packet_len = LE_32(this->buf + 8) + 4;
     if (header->packet_len > BUF_SIZE - 12) {
+        lprintf("mms: get_packet_header error cmd packet length > bufsize\n");
         header->packet_len = 0;
-        goto error;
+        return MMS_PACKET_ERR;
     }
-    lprintf("mms command\n");
     packet_type = MMS_PACKET_COMMAND;
   } else {
     header->packet_seq     = LE_32(this->buf);
@@ -559,10 +551,8 @@ static int get_packet_header (mms_io_t *io, mms_t *this, mms_packet_header_t *he
     header->flags          = this->buf[5];
     header->packet_len     = (LE_16(this->buf + 6) - 8) & 0xffff;
     if (header->packet_id_type == ASF_HEADER_PACKET_ID_TYPE) {
-      lprintf("asf header\n");
       packet_type = MMS_PACKET_ASF_HEADER;
     } else {
-      lprintf("asf packet\n");
       packet_type = MMS_PACKET_ASF_PACKET;
     }
   }
@@ -570,8 +560,7 @@ static int get_packet_header (mms_io_t *io, mms_t *this, mms_packet_header_t *he
   return packet_type;
   
 error:
-  lprintf("read error, len=%ld\n", len);
-  perror("Could not read packet header");
+  lprintf("mms: error reading packet header\n");
   return MMS_PACKET_ERR;
 }
 
@@ -582,12 +571,10 @@ static int get_packet_command (mms_io_t *io, mms_t *this, uint32_t packet_len) {
   int  command = 0;
   size_t len;
   
-  /* always enter this loop */
-  lprintf("packet_len: %d bytes\n", packet_len);
-
   len = io_read(io,  this->s, this->buf + 12, packet_len) ;
   //this->buf_packet_seq_offset = -1; // already set in get_packet_header
   if (len != packet_len) {
+    lprintf("mms: error reading command packet\n");
     return 0;
   }
 
@@ -595,14 +582,14 @@ static int get_packet_command (mms_io_t *io, mms_t *this, uint32_t packet_len) {
   
   /* check protocol type ("MMS ") */
   if (LE_32(this->buf + 12) != 0x20534D4D) {
-    lprintf("unknown protocol type: %c%c%c%c (0x%08X)\n",
+    lprintf("mms: unknown protocol type: %c%c%c%c (0x%08X)\n",
             this->buf[12], this->buf[13], this->buf[14], this->buf[15],
             LE_32(this->buf + 12));  
     return 0;
   }
 
   command = LE_32 (this->buf + 36) & 0xFFFF;
-  lprintf("command = 0x%2x\n", command);
+  lprintf("mms: received command = %02x, len: %d\n", command, packet_len);
     
   return command;
 }
@@ -613,19 +600,15 @@ static int get_answer (mms_io_t *io, mms_t *this) {
 
   switch (get_packet_header (io, this, &header)) {
     case MMS_PACKET_ERR:
-  /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-	      "libmms: failed to read mms packet header\n");
       break;
     case MMS_PACKET_COMMAND:
       command = get_packet_command (io, this, header.packet_len);
-      
+      if (command == 0)
+        return 0;
+
       if (command == 0x1b) {
-    
         if (!send_command (io, this, 0x1b, 0, 0, 0)) {
-  /* FIXME: de-xine-ification */
-          lprintf( "***LOG:*** -- "
-		  "libmms: failed to send command\n");
+          lprintf("mms: error sending ping reply\n");
           return 0;
         }
         /* FIXME: limit recursion */
@@ -633,14 +616,10 @@ static int get_answer (mms_io_t *io, mms_t *this) {
       }
       break;
     case MMS_PACKET_ASF_HEADER:
-  /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-	      "libmms: unexpected asf header packet\n");
+      lprintf("mms: unexpected asf header packet\n");
       break;
     case MMS_PACKET_ASF_PACKET:
-  /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-"libmms: unexpected asf packet\n");
+      lprintf("mms: unexpected asf packet\n");
       break;
   }
   
@@ -662,53 +641,42 @@ static int get_asf_header (mms_io_t *io, mms_t *this) {
 
     switch (get_packet_header (io, this, &header)) {
       case MMS_PACKET_ERR:
-  /* FIXME: de-xine-ification */
-        lprintf( "***LOG:*** -- "
-	       "libmms: failed to read mms packet header\n");
         return 0;
-        break;
       case MMS_PACKET_COMMAND:
         command = get_packet_command (io, this, header.packet_len);
-      
+        if (command == 0)
+          return 0;
+
         if (command == 0x1b) {
-    
           if (!send_command (io, this, 0x1b, 0, 0, 0)) {
-  /* FIXME: de-xine-ification */
-            lprintf( "***LOG:*** -- "
-		   "libmms: failed to send command\n");
+            lprintf("mms: error sending ping reply\n");
             return 0;
           }
           command = get_answer (io, this);
         } else {
-  /* FIXME: de-xine-ification */
-          lprintf( "***LOG:*** -- "
-		 "libmms: unexpected command packet\n");
+          lprintf("mms: unexpected command packet\n");
         }
         break;
       case MMS_PACKET_ASF_HEADER:
       case MMS_PACKET_ASF_PACKET:
         if (header.packet_len + this->asf_header_len > ASF_HEADER_LEN) {
-            lprintf( "***LOG:*** -- "
-                     "libmms: asf packet too large: %d\n", 
-                     header.packet_len + this->asf_header_len);
+            lprintf("mms: asf packet too large: %d\n", 
+                    header.packet_len + this->asf_header_len);
             return 0;
         }
         len = io_read(io,  this->s,
                               this->asf_header + this->asf_header_len, header.packet_len);
         if (len != header.packet_len) {
-  /* FIXME: de-xine-ification */
-          lprintf( "***LOG:*** -- "
-		 "libmms: get_asf_header failed\n");
+           lprintf("mms: error reading asf header\n");
            return 0;
         }
         this->asf_header_len += header.packet_len;
-        lprintf("header flags: %d\n", header.flags);
+        lprintf("mms: header flags: %d\n", header.flags);
         if ((header.flags == 0X08) || (header.flags == 0X0C))
           stop = 1;
         break;
     }
   }
-  lprintf ("get header packet succ\n");
   return 1;
 }
 
@@ -746,15 +714,15 @@ static void interp_stream_properties(mms_t *this, int i)
   stream_id = flags & 0x7F;
   encrypted = flags >> 15;
 
-  lprintf ("stream object, stream id: %d, type: %d, encrypted: %d\n",
-           stream_id, type, encrypted);
+  lprintf("mms: stream object, stream id: %d, type: %d, encrypted: %d\n",
+          stream_id, type, encrypted);
 
   if (this->num_stream_ids < ASF_MAX_NUM_STREAMS) {
     this->streams[this->num_stream_ids].stream_type = type;
     this->streams[this->num_stream_ids].stream_id = stream_id;
     this->num_stream_ids++;
   } else {
-    lprintf ("too many streams, skipping\n");
+    lprintf("mms: too many streams, skipping\n");
   }
 }
 
@@ -786,17 +754,16 @@ static void interp_asf_header (mms_t *this) {
 
         this->asf_packet_len = LE_32(this->asf_header + i + 92);
         if (this->asf_packet_len > BUF_SIZE) {
+          lprintf("mms: asf packet len too large: %d\n", this->asf_packet_len);
           this->asf_packet_len = 0;
-          lprintf( "***LOG:*** -- "
-                   "libmms: asf packet len too large\n");
           break;
         }
         this->file_len       = LE_64(this->asf_header + i + 40);
         this->time_len       = LE_64(this->asf_header + i + 64);
         //this->time_len       = LE_64(this->asf_header + i + 72);
         this->preroll        = LE_64(this->asf_header + i + 80);
-        lprintf ("file object, packet length = %d (%d)\n",
-                 this->asf_packet_len, LE_32(this->asf_header + i + 96));
+        lprintf("mms: file object, packet length = %d (%d)\n",
+                this->asf_packet_len, LE_32(this->asf_header + i + 96));
         break;
 
       case GUID_ASF_STREAM_PROPERTIES:
@@ -809,13 +776,9 @@ static void interp_asf_header (mms_t *this) {
           uint16_t stream_id;
           int j;
 
-          lprintf ("stream bitrate properties\n");
-          lprintf ("streams %d\n", streams); 
-
           for(j = 0; j < streams; j++) {
             int stream_index;
             stream_id = LE_16(this->asf_header + i + 24 + 2 + j * 6);
-            lprintf ("stream id %d\n", stream_id);
             for(stream_index = 0; stream_index < this->num_stream_ids; stream_index++) {
               if (this->streams[stream_index].stream_id == stream_id)
                 break;
@@ -823,9 +786,10 @@ static void interp_asf_header (mms_t *this) {
             if (stream_index < this->num_stream_ids) {
               this->streams[stream_index].bitrate = LE_32(this->asf_header + i + 24 + 4 + j * 6);
               this->streams[stream_index].bitrate_pos = i + 24 + 4 + j * 6;
-              lprintf ("stream id %d, bitrate %d\n", stream_id, 
-                     this->streams[stream_index].bitrate);
-            }
+              lprintf("mms: stream id %d, bitrate %d\n", stream_id, 
+                      this->streams[stream_index].bitrate);
+            } else
+              lprintf("mms: error bitrate stream id %d not found\n", stream_id);
           }
         }
         break;
@@ -838,7 +802,7 @@ static void interp_asf_header (mms_t *this) {
           int size = LE_32(this->asf_header + i + 24 + 18);
           int j = 24 + 18 + 4;
           int l;
-          lprintf("Extension header data size: %d\n", size);
+          lprintf("mms: Extension header data size: %d\n", size);
 
           while ((j + 24) <= length) {
             guid = get_guid(this->asf_header, i + j);
@@ -855,10 +819,9 @@ static void interp_asf_header (mms_t *this) {
                   int ext_j = 24 + 64;
                   int x;
 
-                  lprintf ("l: %d\n", l);
-                  lprintf ("Stream No: %d\n", stream_no);
-                  lprintf ("Name count: %d\n", name_count);
-                  lprintf ("ext_count: %d\n", ext_count);
+                  lprintf("mms: l: %d\n", l);
+                  lprintf("mms: Stream No: %d\n", stream_no);
+                  lprintf("mms: ext_count: %d\n", ext_count);
 
                   // Loop through the number of stream names
                   for (x = 0; x < name_count && (ext_j + 4) <= l; x++) {
@@ -871,8 +834,8 @@ static void interp_asf_header (mms_t *this) {
                     stream_name_len = LE_16(this->asf_header + i + j + ext_j);
                     ext_j += stream_name_len + 2;
 
-                    lprintf ("Language id index: %d\n", lang_id_index);
-                    lprintf ("Stream name Len: %d\n", stream_name_len);
+                    lprintf("mms: Language id index: %d\n", lang_id_index);
+                    lprintf("mms: Stream name Len: %d\n", stream_name_len);
                   }
 
                   // Loop through the number of extension system info
@@ -882,7 +845,7 @@ static void interp_asf_header (mms_t *this) {
                     ext_j += 4 + len;
                   }
 
-                  lprintf ("ext_j: %d\n", ext_j);
+                  lprintf("mms: ext_j: %d\n", ext_j);
                   // Finally, we arrive at the interesting point: The optional Stream Property Object
                   if ((ext_j + 24) <= l) {
                     guid = get_guid(this->asf_header, i + j + ext_j);
@@ -892,7 +855,7 @@ static void interp_asf_header (mms_t *this) {
                       interp_stream_properties(this, i + j + ext_j + 24);
                     }
                   } else {
-                    lprintf ("Sorry, field not long enough\n");
+                    lprintf("mms: Sorry, field not long enough\n");
                   }
             }
             j += l;
@@ -903,13 +866,9 @@ static void interp_asf_header (mms_t *this) {
       case GUID_ASF_DATA:
         this->asf_num_packets = LE_64(this->asf_header + i + 40 - 24);
         break;
-
-      default:
-        lprintf ("unknown object\n");
-        break;
     }
 
-    lprintf ("length: %llu\n", (unsigned long long)length);
+    lprintf("mms: length: %llu\n", (unsigned long long)length);
     i += length;
   }
 }
@@ -919,8 +878,6 @@ const static char *const mmst_proto_s[] = { "mms", "mmst", NULL };
 static int mmst_valid_proto (char *proto) {
   int i = 0;
 
-  lprintf("mmst_valid_proto\n");
-
   if (!proto)
     return 0;
 
@@ -962,12 +919,10 @@ static int mms_tcp_connect(mms_io_t *io, mms_t *this) {
   /* 
    * try to connect 
    */
-  lprintf("try to connect to %s on port %d \n", this->host, this->port);
+  lprintf("mms: trying to connect to %s on port %d\n", this->host, this->port);
   this->s = io_connect(io,  this->host, this->port);
   if (this->s == -1) {
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	    "failed to connect '%s'\n", this->host);
+    lprintf("mms: failed to connect to %s\n", this->host);
     return 1;
   }
 
@@ -982,7 +937,7 @@ static int mms_tcp_connect(mms_io_t *io, mms_t *this) {
   if (res != MMS_IO_STATUS_READY) {
     return 1;
   }
-  lprintf ("connected\n");
+  lprintf("mms: connected\n");
   return 0;
 }
 
@@ -1026,7 +981,6 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
   /* command 0x33 */
   /* choose the best quality for the audio stream */
   /* i've never seen more than one audio stream */
-  lprintf("num_stream_ids=%d\n", this->num_stream_ids);
   for (i = 0; i < this->num_stream_ids; i++) {
     switch (this->streams[i].stream_type) {
       case ASF_STREAM_TYPE_AUDIO:
@@ -1045,7 +999,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
   if (bandwitdh_left < 0) {
     bandwitdh_left = 0;
   }
-  lprintf("bandwitdh %d, left %d\n", this->bandwidth, bandwitdh_left);
+  lprintf("mms: bandwidth %d, left %d\n", this->bandwidth, bandwitdh_left);
 
   min_bw_left = bandwitdh_left;
   for (i = 0; i < this->num_stream_ids; i++) {
@@ -1079,8 +1033,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
     }
   }
     
-  lprintf("selected streams: audio %d, video %d\n", audio_stream, video_stream);
-  lprintf("disabling other streams\n");
+  lprintf("mms: selected streams: audio %d, video %d\n", audio_stream, video_stream);
   memset (this->scmd_body, 0, 40);
   for (i = 1; i < this->num_stream_ids; i++) {
     this->scmd_body [ (i - 1) * 6 + 2 ] = 0xFF;
@@ -1092,7 +1045,7 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
       this->scmd_body [ (i - 1) * 6 + 6 ] = 0x00;
       this->scmd_body [ (i - 1) * 6 + 7 ] = 0x00;
     } else {
-      lprintf("disabling stream %d\n", this->streams[i].stream_id);
+      lprintf("mms: disabling stream %d\n", this->streams[i].stream_id);
       this->scmd_body [ (i - 1) * 6 + 6 ] = 0x02;
       this->scmd_body [ (i - 1) * 6 + 7 ] = 0x00;
       
@@ -1104,26 +1057,23 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
           this->asf_header[this->streams[i].bitrate_pos + 2] = 0;
           this->asf_header[this->streams[i].bitrate_pos + 3] = 0;
         } else {
-          lprintf("***LOG:*** -- "
-                  "libmms: attempt to write beyond asf header limit");
+          lprintf("mms: attempt to write beyond asf header limit\n");
         }
       }
     }
   }
 
+  lprintf("mms: send command 0x33\n");
   if (!send_command (io, this, 0x33, this->num_stream_ids, 
                      0xFFFF | this->streams[0].stream_id << 16, 
                      this->num_stream_ids * 6 + 2)) {
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	     "libmms: mms_choose_best_streams failed\n");
+    lprintf("mms: mms_choose_best_streams failed\n");
     return 0;
   }
 
   if ((res = get_answer (io, this)) != 0x21) {
-    /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	     "libmms: unexpected response: %02x (0x21)\n", res);
+    lprintf("mms: unexpected response: %02x (0x21)\n", res);
+    return 0;
   }
 
   res = LE_32(this->buf + 40);
@@ -1182,7 +1132,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   
   this->guri = gnet_uri_new(this->url);
   if(!this->guri) {
-    lprintf ("invalid url\n");
+    lprintf("mms: invalid url\n");
     goto fail;
   }
   this->proto = this->guri->scheme;
@@ -1196,7 +1146,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 	goto fail;
 
   if (!mmst_valid_proto(this->proto)) {
-    lprintf ("unsupported protocol\n");
+    lprintf("mms: unsupported protocol: %s\n", this->proto);
     goto fail;
   }
   
@@ -1214,24 +1164,19 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
    */
 
   /* command 0x1 */
-  lprintf("send command 0x01\n");
+  lprintf("mms: send command 0x01\n");
   mms_gen_guid(this->guid);
   sprintf (this->str, "\x1c\x03NSPlayer/7.0.0.1956; {%s}; Host: %s",
     this->guid, this->host);
   string_utf16 (url_conv, this->scmd_body, this->str, strlen(this->str) + 2);
 
   if (!send_command (io, this, 1, 0, 0x0004000b, strlen(this->str) * 2 + 8)) {
-  /* FIXME: de-xine-ification */
-    lprintf( "***LOG:*** -- "
-	    "libmms: failed to send command 0x01\n");
+    lprintf("mms: failed to send command 0x01\n");
     goto fail;
   }
   
   if ((res = get_answer (io, this)) != 0x01) {
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	     "libmms: unexpected response: %02x (0x01)\n", res);
-    lprintf("answer: %d\n", res);
+    lprintf("mms: unexpected response: %02x (0x01)\n", res);
     goto fail;
   }
 
@@ -1247,14 +1192,11 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 
   /* TODO: insert network timing request here */
   /* command 0x2 */
-  lprintf("send command 0x02\n");
+  lprintf("mms: send command 0x02\n");
   string_utf16 (url_conv, &this->scmd_body[8], "\002\000\\\\192.168.0.129\\TCP\\1037\0000", 28);
   memset (this->scmd_body, 0, 8);
   if (!send_command (io, this, 2, 0, 0, 28 * 2 + 8)) {
-  /* FIXME: de-xine-ification */
-    lprintf( "***LOG:*** -- "
-	    "libmms: failed to send command 0x02\n");
-
+    lprintf("mms: failed to send command 0x02\n");
     goto fail;
   }
 
@@ -1263,13 +1205,10 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
       /* protocol accepted */
       break;
     case 0x03:
-  /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-	      "libmms: protocol failed\n");
+      lprintf("mms: protocol failed\n");
       goto fail;
-      break;
     default:
-      lprintf("unexpected response: %02x (0x02 or 0x03)\n", res);
+      lprintf("mms: unexpected response: %02x (0x02 or 0x03)\n", res);
       goto fail;
   }
 
@@ -1287,7 +1226,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   {
     mms_buffer_t command_buffer;
     
-    lprintf("send command 0x05\n");
+    lprintf("mms: send command 0x05\n");
     mms_buffer_init(&command_buffer, this->scmd_body);
     mms_buffer_put_32 (&command_buffer, 0x00000000); /* ?? */
     mms_buffer_put_32 (&command_buffer, 0x00000000); /* ?? */
@@ -1320,15 +1259,11 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
       break;
     case 0x1A:
       /* authentication request, not yet supported */
-  /* FIXME: de-xine-ification */
-      lprintf ( "***LOG:*** -- "
-	       "libmms: authentication request, not yet supported\n");
+      lprintf("mms: authentication request, not yet supported\n");
       goto fail;
       break;
     default:
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	     "libmms: unexpected response: %02x (0x06 or 0x1A)\n", res);
+      lprintf("mms: unexpected response: %02x (0x06 or 0x1A)\n", res);
       goto fail;
   }
 
@@ -1343,7 +1278,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 /*   report_progress (stream, 60); */
 
   /* command 0x15 */
-  lprintf("send command 0x15\n");
+  lprintf("mms: send command 0x15\n");
   {
     mms_buffer_t command_buffer;
     mms_buffer_init(&command_buffer, this->scmd_body);
@@ -1358,17 +1293,13 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     mms_buffer_put_32 (&command_buffer, ASF_HEADER_PACKET_ID_TYPE);   /* Header Packet ID type */
     mms_buffer_put_32 (&command_buffer, 0x00000000);                  /* ?? */
     if (!send_command (io, this, 0x15, openid, 0, command_buffer.pos)) {
-  /* FIXME: de-xine-ification */
-      lprintf ( "***LOG:*** -- "
-	       "libmms: failed to send command 0x15\n");
+      lprintf("mms: failed to send command 0x15\n");
       goto fail;
     }
   }
   
   if ((res = get_answer (io, this)) != 0x11) {
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-             "libmms: unexpected response: %02x (0x11)\n", res);
+    lprintf("mms: unexpected response: %02x (0x11)\n", res);
     goto fail;
   }
 
@@ -1392,9 +1323,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 /*   report_progress (stream, 70); */
 
   if (!mms_choose_best_streams(io, this)) {
-  /* FIXME: de-xine-ification */
-    lprintf ( "***LOG:*** -- "
-	     "libmms: mms_choose_best_streams failed");
+    lprintf("mms: mms_choose_best_streams failed\n");
     goto fail;
   }
 
@@ -1416,9 +1345,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     mms_buffer_put_8  (&command_buffer, 0x00);                        /* stream time limit flag */
     mms_buffer_put_32 (&command_buffer, this->packet_id_type);    /* asf media packet id type */
     if (!send_command (io, this, 0x07, 1, 0x0001FFFF, command_buffer.pos)) {
-  /* FIXME: de-xine-ification */
-      lprintf ( "***LOG:*** -- "
-	       "libmms: failed to send command 0x07\n");
+      lprintf("mms: failed to send command 0x07\n");
       goto fail;
     }
   }
@@ -1429,7 +1356,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   string_utf16_close(url_conv);
 #endif
 
-  lprintf("mms_connect: passed\n" );
+  lprintf("mms: connect: passed\n");
  
   return this;
 
@@ -1453,11 +1380,7 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
   
   switch (get_packet_header (io, this, &header)) {
     case MMS_PACKET_ERR:
-  /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-	      "libmms: failed to read mms packet header\n");
       return 0;
-      break;
     
     case MMS_PACKET_COMMAND:
       {
@@ -1465,13 +1388,16 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
         command = get_packet_command (io, this, header.packet_len);
       
         switch (command) {
+          case 0:
+            return 0;
+
           case 0x1e:
             {
               uint32_t error_code;
 
               /* Warning: sdp is incomplete. Do not stop if error_code==1 */
               error_code = LE_32(this->buf + CMD_HEADER_LEN);
-              lprintf ("End of the current stream. Continue=%d\n", error_code);
+              lprintf("mms: End of the current stream. Continue=%d\n", error_code);
 
               if (error_code == 0) {
                 this->eos = 1;
@@ -1483,12 +1409,10 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
   
           case 0x20:
             {
-              lprintf ("new stream.\n");
+              lprintf("mms: new stream.\n");
               /* asf header */
               if (!get_asf_header (io, this)) {
-		/* FIXME: de-xine-ification */
-                lprintf ( "***LOG:*** -- "
-			 "failed to read new ASF header\n");
+                lprintf("mms: failed to read new ASF header\n");
                 return 0;
               }
 
@@ -1515,9 +1439,7 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
                 mms_buffer_put_8  (&command_buffer, 0x00);                        /* stream time limit flag */
                 mms_buffer_put_32 (&command_buffer, ASF_MEDIA_PACKET_ID_TYPE);    /* asf media packet id type */
                 if (!send_command (io, this, 0x07, 1, 0x0001FFFF, command_buffer.pos)) {
-		  /* FIXME: de-xine-ification */
-                  lprintf ( "***LOG:*** -- "
-			   "libmms: failed to send command 0x07\n");
+                  lprintf("mms: failed to send command 0x07\n");
                   return 0;
                 }
               }
@@ -1533,9 +1455,7 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
           case 0x1b:
             {
               if (!send_command (io, this, 0x1b, 0, 0, 0)) {
-		/* FIXME: de-xine-ification */
-                lprintf( "***LOG:*** -- "
-			"libmms: failed to send command\n");
+                lprintf("mms: error sending ping reply\n");
                 return 0;
               }
             }
@@ -1545,18 +1465,14 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
             break;
   
           default:
-	    /* FIXME: de-xine-ification */
-	    lprintf ( "***LOG:*** -- "
-                     "unexpected mms command %02x\n", command);
+	    lprintf("mms: unexpected mms command %02x\n", command);
         }
         this->buf_size = 0;
       }
       break;
 
     case MMS_PACKET_ASF_HEADER:
-      /* FIXME: de-xine-ification */
-      lprintf( "***LOG:*** -- "
-	      "libmms: unexpected asf header packet\n");
+      lprintf("mms: unexpected asf header packet\n");
       this->buf_size = 0;
       break;
 
@@ -1573,12 +1489,8 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
 	  this->start_packet_seq = header.packet_seq;
 	}
 	
-        lprintf ("asf media packet detected, packet_len=%d, packet_seq=%d\n",
-                 header.packet_len, header.packet_seq);
         if (header.packet_len > this->asf_packet_len) {
-	  /* FIXME: de-xine-ification */
-	  lprintf ( "***LOG:*** -- "
-                   "libmms: invalid asf packet len: %d bytes\n", header.packet_len);
+	  lprintf("mms: invalid asf packet len: %d bytes\n", header.packet_len);
           return 0;
         }
     
@@ -1588,14 +1500,11 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
 
         len = io_read(io,  this->s, this->buf, header.packet_len);
         if (len != header.packet_len) {
-	  /* FIXME: de-xine-ification */
-          lprintf ( "***LOG:*** -- "
-		   "libmms: read failed\n");
+          lprintf("mms: error reading asf packet\n");
           return 0;
         }
 
         /* explicit padding with 0 */
-        lprintf("padding: %d bytes\n", this->asf_packet_len - header.packet_len);
 	{
 	  char *base  = (char *)(this->buf);
 	  char *start = base + header.packet_len;
@@ -1624,8 +1533,6 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
       }
       break;
   }
-  
-  lprintf ("get media packet succ\n");
 
   return 1;
 }
@@ -1670,9 +1577,7 @@ int mms_read (mms_io_t *io, mms_t *this, char *data, int len) {
       if (bytes_left == 0) {
         this->buf_size = this->buf_read = 0;
         if (!get_media_packet (io, this)) {
-  /* FIXME: de-xine-ification */
-          lprintf ( "***LOG:*** -- "
-		   "libmms: get_media_packet failed\n");
+          lprintf("mms: get_media_packet failed\n");
           return total;
         }
         bytes_left = this->buf_size;
@@ -1714,9 +1619,7 @@ static int mms_request_data_packet (mms_io_t *io, mms_t *this,
     mms_buffer_put_32 (&command_buffer, time_msec_limit & 0x00FFFFFF);/* max stream time limit (3 bytes) */
     mms_buffer_put_32 (&command_buffer, this->packet_id_type);    /* asf media packet id type */
     if (!send_command (io, this, 0x07, 1, 0x0001FFFF, 8+command_buffer.pos)) {
-  /* FIXME: de-xine-ification */
-      lprintf ( "***LOG:*** -- "
-	       "libmms: failed to send command 0x07\n");
+      lprintf("mms: failed to send command 0x07\n");
       return 0;
     }
   }
@@ -1750,9 +1653,7 @@ static int peek_and_set_pos (mms_io_t *io, mms_t *this) {
   while (!this->eos) {
     // get_media_packet() will set current_pos if data packet is read.
     if (!get_media_packet (io, this)) {
-  /* FIXME: de-xine-ification */
-      lprintf ( "***LOG:*** -- "
-               "libmms: get_media_packet failed\n");
+      lprintf("mms: get_media_packet failed\n");
       // restore buf and buf_size that may be changed in get_media_packet()
       memcpy(this->buf, saved_buf, saved_buf_size);
       this->buf_size = saved_buf_size;
-- 
1.7.0

From be7c2960f52b8d61a31235dad4417ceacedfc6da Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Mon, 15 Feb 2010 00:01:18 +0100
Subject: [PATCH 20/22] Fixup overcomplicated 0 padding

---
 src/mms.c  |   36 ++++++++++++------------------------
 src/mmsh.c |   19 ++++---------------
 2 files changed, 16 insertions(+), 39 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index a50c7d9..e6f1e19 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -1505,30 +1505,18 @@ static int get_media_packet (mms_io_t *io, mms_t *this) {
         }
 
         /* explicit padding with 0 */
-	{
-	  char *base  = (char *)(this->buf);
-	  char *start = base + header.packet_len;
-	  char *end   = start + this->asf_packet_len - header.packet_len;
-	  if ((start > base) && (start < (base+BUF_SIZE-1)) &&
-	      (start < end)  && (end < (base+BUF_SIZE-1))) {
-	    memset(this->buf + header.packet_len, 0, this->asf_packet_len - header.packet_len);
- 	  }
-          if (header.packet_id_type == this->packet_id_type) {
-	  if (this->asf_packet_len > BUF_SIZE) {
-            this->buf_size = BUF_SIZE;
-          } else {
-            this->buf_size = this->asf_packet_len;
-          }
-            this->buf_packet_seq_offset =
-              header.packet_seq - this->start_packet_seq;
-          } else {
-            this->buf_size = 0;
-            // Don't set this packet sequence for reuse in seek(), since the
-            // subsequence packet may be discontinued.
-            //this->buf_packet_seq_offset = header.packet_seq;
-            // already set to -1 in get_packet_header
-            //this->buf_packet_seq_offset = -1;
-          }
+        memset(this->buf + header.packet_len, 0, this->asf_packet_len - header.packet_len);
+        if (header.packet_id_type == this->packet_id_type) {
+          this->buf_size = this->asf_packet_len;
+          this->buf_packet_seq_offset =
+            header.packet_seq - this->start_packet_seq;
+        } else {
+          this->buf_size = 0;
+          // Don't set this packet sequence for reuse in seek(), since the
+          // subsequence packet may be discontinued.
+          //this->buf_packet_seq_offset = header.packet_seq;
+          // already set to -1 in get_packet_header
+          //this->buf_packet_seq_offset = -1;
 	}
       }
       break;
diff --git a/src/mmsh.c b/src/mmsh.c
index 5ee348e..cd396c9 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -1248,21 +1248,10 @@ static int get_media_packet (mms_io_t *io, mmsh_t *this) {
 	return ERROR;
       }
 
-      {
-	char *base  = (char *)(this->buf);
-	char *start = base + this->chunk_length;
-	char *end   = start + this->packet_length - this->chunk_length;
-	if ((start > base) && (start < (base+CHUNK_SIZE-1)) &&
-	    (start < end)  && (end < (base+CHUNK_SIZE-1))) {
-	  memset(start, 0,
-		 this->packet_length - this->chunk_length);
-	}
-	if (this->packet_length > CHUNK_SIZE) {
-	  this->buf_size = CHUNK_SIZE;
-	} else {
-	  this->buf_size = this->packet_length;
-	}
-      }
+      memset(this->buf + this->chunk_length, 0,
+             this->packet_length - this->chunk_length);
+      this->buf_size = this->packet_length;
+
       return SUCCESS;
     } else {
       lprintf("mmsh: media packet read error, %d != %d\n", len,
-- 
1.7.0

From 734f039cca32070a19a9211b84e38ce6e2d7648f Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Wed, 17 Feb 2010 17:06:02 +0100
Subject: [PATCH 21/22] mms: remove percent escaping from uri before sending it to the server

Also see:
http://bugs.xine-project.org/show_bug.cgi?id=99

The percent unescaping is easy, but in order for this to work properly
this patch also switches the input url to unicode conversion over to
iconv, and removes the embedding of non string values inside a string
to be converted to unicode the code was doing in some places, as that
may well break when using iconv (and is just plain ugly).

While at it also fixup 2 small spec compliance issues (bring us
inline with 2 "shoulds" in the spec.
---
 src/mms.c |  133 +++++++++++++++++++++++++------------------------------------
 1 files changed, 55 insertions(+), 78 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index e6f1e19..8fef2da 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -40,13 +40,7 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <time.h>
-
-#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_CODESET)
-#define USE_ICONV
 #include <iconv.h>
-#include <locale.h>
-#include <langinfo.h>
-#endif
 
 /********** logging **********/
 #define lprintf(...) if (getenv("LIBMMS_DEBUG")) fprintf(stderr, __VA_ARGS__)
@@ -464,56 +458,23 @@ static int send_command (mms_io_t *io, mms_t *this, int command,
   return 1;
 }
 
-#ifdef USE_ICONV
-static iconv_t string_utf16_open() {
-    return iconv_open("UTF-16LE", nl_langinfo(CODESET));
-}
-
-static void string_utf16_close(iconv_t url_conv) {
-    if (url_conv != (iconv_t)-1) {
-      iconv_close(url_conv);
-    }
-}
-
-static void string_utf16(iconv_t url_conv, char *dest, char *src, int len) {
-    memset(dest, 0, 2 * len);
-
-    if (url_conv == (iconv_t)-1) {
-      int i;
-
-      for (i = 0; i < len; i++) {
-        dest[i * 2] = src[i];
-        dest[i * 2 + 1] = 0;
-      }
-      dest[i * 2] = 0;
-      dest[i * 2 + 1] = 0;
-    }
-    else {
-      size_t len1, len2;
-      char *ip, *op;
-
-      len1 = len; len2 = 1000;
-      ip = src; op = dest;
-      iconv(url_conv, &ip, &len1, &op, &len2);
-    }
-}
-
-#else
-static void string_utf16(int unused, char *dest, char *src, int len) {
-  int i;
-
-  memset (dest, 0, 2 * len);
+static int string_utf16(iconv_t url_conv, char *dest, char *src, int dest_len)
+{
+  char *ip = src, *op = dest;
+  size_t ip_len = strlen(src);
+  size_t op_len = dest_len - 2; /* reserve 2 bytes for 0 termination */
 
-  for (i = 0; i < len; i++) {
-    dest[i * 2] = src[i];
-    dest[i * 2 + 1] = 0;
+  if (iconv(url_conv, &ip, &ip_len, &op, &op_len) == (size_t)-1) {
+    lprintf("mms: Error converting uri to unicode: %s\n", strerror(errno));
+    return 0;
   }
+  
+  /* 0 terminate the string */
+  *op++ = 0;
+  *op++ = 0;
 
-  dest[i * 2] = 0;
-  dest[i * 2 + 1] = 0;
+  return op - dest;
 }
-#endif
-
 
 /*
  * return packet type
@@ -1092,14 +1053,11 @@ int static mms_choose_best_streams(mms_io_t *io, mms_t *this) {
  */
 /* FIXME: got somewhat broken during xine_stream_t->(void*) conversion */
 mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
-#ifdef USE_ICONV
-  iconv_t url_conv;
-#else
-  int     url_conv = 0;
-#endif
+  iconv_t url_conv = (iconv_t)-1;
   mms_t  *this;
   int     res;
   uint32_t openid;
+  mms_buffer_t command_buffer;
   
   if (!url)
     return NULL;
@@ -1135,6 +1093,10 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     lprintf("mms: invalid url\n");
     goto fail;
   }
+  
+  /* MMS wants unescaped (so not percent coded) strings */
+  gnet_uri_unescape(this->guri);
+
   this->proto = this->guri->scheme;
   this->user = this->guri->user;
   this->host = this->guri->hostname;
@@ -1156,21 +1118,29 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   /* FIXME de-xine-ification */
 /*   report_progress (stream, 30); */
   
-#ifdef USE_ICONV
-  url_conv = string_utf16_open();
-#endif
+  url_conv = iconv_open("UTF-16LE", "UTF-8");
+  if (url_conv == (iconv_t)-1) {
+    lprintf("mms: could not get iconv handle to convert url to unicode\n");
+    goto fail;
+  }
+
   /*
    * let the negotiations begin...
    */
 
   /* command 0x1 */
   lprintf("mms: send command 0x01\n");
+  mms_buffer_init(&command_buffer, this->scmd_body);
+  mms_buffer_put_32 (&command_buffer, 0x0003001C);
   mms_gen_guid(this->guid);
-  sprintf (this->str, "\x1c\x03NSPlayer/7.0.0.1956; {%s}; Host: %s",
-    this->guid, this->host);
-  string_utf16 (url_conv, this->scmd_body, this->str, strlen(this->str) + 2);
+  sprintf(this->str, "NSPlayer/7.0.0.1956; {%s}; Host: %s", this->guid,
+          this->host);
+  res = string_utf16(url_conv, this->scmd_body + command_buffer.pos, this->str,
+                     CMD_BODY_LEN - command_buffer.pos);
+  if(!res)
+    goto fail;
 
-  if (!send_command (io, this, 1, 0, 0x0004000b, strlen(this->str) * 2 + 8)) {
+  if (!send_command(io, this, 1, 0, 0x0004000b, command_buffer.pos + res)) {
     lprintf("mms: failed to send command 0x01\n");
     goto fail;
   }
@@ -1193,9 +1163,17 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   /* TODO: insert network timing request here */
   /* command 0x2 */
   lprintf("mms: send command 0x02\n");
-  string_utf16 (url_conv, &this->scmd_body[8], "\002\000\\\\192.168.0.129\\TCP\\1037\0000", 28);
-  memset (this->scmd_body, 0, 8);
-  if (!send_command (io, this, 2, 0, 0, 28 * 2 + 8)) {
+  mms_buffer_init(&command_buffer, this->scmd_body);
+  mms_buffer_put_32 (&command_buffer, 0x00000000);
+  mms_buffer_put_32 (&command_buffer, 0x00989680);
+  mms_buffer_put_32 (&command_buffer, 0x00000002);
+  res = string_utf16(url_conv, this->scmd_body + command_buffer.pos,
+                     "\\\\192.168.0.129\\TCP\\1037",
+                     CMD_BODY_LEN - command_buffer.pos);
+  if(!res)
+    goto fail;
+
+  if (!send_command(io, this, 2, 0, 0xffffffff, command_buffer.pos + res)) {
     lprintf("mms: failed to send command 0x02\n");
     goto fail;
   }
@@ -1231,15 +1209,15 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     mms_buffer_put_32 (&command_buffer, 0x00000000); /* ?? */
     mms_buffer_put_32 (&command_buffer, 0x00000000); /* ?? */
 
-    /* FIXME: refuse to work with urls that are longer that buffer can hold
-       64 is a precation */
-
-    if (strlen(this->uri) >= CMD_BODY_LEN - 64)
-	goto fail;
+    res = string_utf16(url_conv, this->scmd_body + command_buffer.pos,
+                       this->uri, CMD_BODY_LEN - command_buffer.pos);
+    if(!res)
+      goto fail;
 
-    string_utf16 (url_conv, this->scmd_body + command_buffer.pos, this->uri, strlen(this->uri));
-    if (!send_command (io, this, 5, 1, 0xffffffff, strlen(this->uri) * 2 + 12))
+    if (!send_command(io, this, 5, 1, 0, command_buffer.pos + res)) {
+      lprintf("mms: failed to send command 0x05\n");
       goto fail;
+    }
   }
   
   switch (res = get_answer (io, this)) {
@@ -1352,10 +1330,7 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
 
 /*   report_progress (stream, 100); */
 
-#ifdef USE_ICONV
-  string_utf16_close(url_conv);
-#endif
-
+  iconv_close(url_conv);
   lprintf("mms: connect: passed\n");
  
   return this;
@@ -1369,6 +1344,8 @@ fail:
     gnet_uri_delete(this->guri);
   if (this->uri)
     free(this->uri);
+  if (url_conv != (iconv_t)-1)
+    iconv_close(url_conv);
 
   free (this);
   return NULL;
-- 
1.7.0

From c286a664ff4474f78732ccd73d7e387584bf27d8 Mon Sep 17 00:00:00 2001
From: Hans de Goede <j.w.r.degoede@hhs.nl>
Date: Wed, 17 Feb 2010 22:35:06 +0100
Subject: [PATCH 22/22] Remove progress reporting and other left-over xine-isms

---
 src/mms.c  |   57 ---------------------------------------------------------
 src/mmsh.c |   24 ------------------------
 2 files changed, 0 insertions(+), 81 deletions(-)

diff --git a/src/mms.c b/src/mms.c
index 8fef2da..ce1194b 100644
--- a/src/mms.c
+++ b/src/mms.c
@@ -101,9 +101,6 @@ struct mms_stream_s {
 
 struct mms_s {
 
-  /* FIXME: de-xine-ification */
-  void *custom_data;
-  
   int           s;
   
   /* url parsing */
@@ -851,30 +848,10 @@ static int mmst_valid_proto (char *proto) {
   return 0;
 }
 
-/* FIXME: de-xine-ification */
-
-/* static void report_progress (void *data, int p) {
-
-  xine_event_t             event;
-  xine_progress_data_t     prg;
-
-  prg.description = _("Connecting MMS server (over tcp)...");
-  prg.percent = p;
-  
-  event.type = XINE_EVENT_PROGRESS;
-  event.data = &prg;
-  event.data_length = sizeof (xine_progress_data_t);
-  
-  xine_event_send (stream, &event);
-} */
-
-
 /*
  * returns 1 on error
  */
 static int mms_tcp_connect(mms_io_t *io, mms_t *this) {
-  int progress, res;
-  
   if (!this->port) this->port = MMST_PORT;
 
   /* 
@@ -887,17 +864,6 @@ static int mms_tcp_connect(mms_io_t *io, mms_t *this) {
     return 1;
   }
 
-  /* connection timeout 15s */
-  progress = 0;
-  do {
-    /*FIXME: de-xine-ification */
-/*     report_progress(this->stream, progress); */
-    res = io_select(io,  this->s, MMS_IO_WRITE_READY, 500);
-    progress += 1;
-  } while ((res == MMS_IO_STATUS_TIMEOUT) && (progress < 30));
-  if (res != MMS_IO_STATUS_READY) {
-    return 1;
-  }
   lprintf("mms: connected\n");
   return 0;
 }
@@ -1065,7 +1031,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   /* FIXME: needs proper error-signalling work */
   this = (mms_t*) malloc (sizeof (mms_t));
 
-  this->custom_data     = data;
   this->url             = strdup (url);
   this->s               = -1;
   this->seq_num         = 0;
@@ -1085,9 +1050,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   this->current_pos     = 0;
   this->eos             = 0;
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 0); */
-  
   this->guri = gnet_uri_new(this->url);
   if(!this->guri) {
     lprintf("mms: invalid url\n");
@@ -1115,8 +1077,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   if (mms_tcp_connect(io, this)) {
     goto fail;
   }
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 30); */
   
   url_conv = iconv_open("UTF-16LE", "UTF-8");
   if (url_conv == (iconv_t)-1) {
@@ -1157,9 +1117,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     goto fail;
   }
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 40); */
-
   /* TODO: insert network timing request here */
   /* command 0x2 */
   lprintf("mms: send command 0x02\n");
@@ -1197,9 +1154,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     goto fail;
   }
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 50); */
-
   /* command 0x5 */
   {
     mms_buffer_t command_buffer;
@@ -1252,9 +1206,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     goto fail;
   }
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 60); */
-
   /* command 0x15 */
   lprintf("mms: send command 0x15\n");
   {
@@ -1297,17 +1248,11 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
   if (!this->asf_packet_len || !this->num_stream_ids)
     goto fail;
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 70); */
-
   if (!mms_choose_best_streams(io, this)) {
     lprintf("mms: mms_choose_best_streams failed\n");
     goto fail;
   }
 
-  /* FIXME de-xine-ification */
-/*   report_progress (stream, 80); */
-
   /* command 0x07 */
   this->packet_id_type = ASF_MEDIA_PACKET_ID_TYPE;
   {
@@ -1328,8 +1273,6 @@ mms_t *mms_connect (mms_io_t *io, void *data, const char *url, int bandwidth) {
     }
   }
 
-/*   report_progress (stream, 100); */
-
   iconv_close(url_conv);
   lprintf("mms: connect: passed\n");
  
diff --git a/src/mmsh.c b/src/mmsh.c
index cd396c9..dd6e39d 100644
--- a/src/mmsh.c
+++ b/src/mmsh.c
@@ -151,9 +151,6 @@ static const char* mmsh_RangeRequest =
 
 struct mmsh_s {
 
-  /* FIXME: de-xine-ification */
-  void *custom_data;
-
   int           s;
 
   /* url parsing */
@@ -810,8 +807,6 @@ static int mmsh_valid_proto (char *proto) {
  * returns 1 on error
  */
 static int mmsh_tcp_connect(mms_io_t *io, mmsh_t *this) {
-  int progress, res;
-  
   if (!this->connect_port) this->connect_port = MMSH_PORT;
   
   /* 
@@ -826,18 +821,6 @@ static int mmsh_tcp_connect(mms_io_t *io, mmsh_t *this) {
     return 1;
   }
 
-  /* connection timeout 15s */
-  progress = 0;
-  do {
-//    report_progress(this->stream, progress);
-    res = io_select (io, this->s, MMS_IO_WRITE_READY, 500);
-    progress += 1;
-  } while ((res == MMS_IO_STATUS_TIMEOUT) && (progress < 30));
-  if (res != MMS_IO_STATUS_READY) {
-    close (this->s);
-    this->s = -1;
-    return 1;
-  }
   lprintf("mmsh: connected\n");
 
   return 0;
@@ -862,7 +845,6 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
   if (mmsh_tcp_connect(io, this)) {
     return 0;
   }
-//  report_progress (stream, 30);
 
   /*
    * let the negotiations begin...
@@ -890,8 +872,6 @@ static int mmsh_connect_int (mms_io_t *io, mmsh_t *this, off_t seek, uint32_t ti
     goto fail;
   
   close(this->s);
-//  report_progress (stream, 20);
-
   
   /* choose the best quality for the audio stream */
   /* i've never seen more than one audio stream */
@@ -1041,7 +1021,6 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
   if (!url)
     return NULL;
 
-//  report_progress (stream, 0);
   /*
    * initializatoin is essential here.  the fail: label depends
    * on the various char * in our this structure to be
@@ -1059,7 +1038,6 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
   this->host_password = NULL;
   this->uri = NULL;
 
-  this->custom_data     = data;
   this->url             = strdup(url);
   if ((proxy_env = getenv("http_proxy")) != NULL)
     this->proxy_url = strdup(proxy_env);
@@ -1078,8 +1056,6 @@ mmsh_t *mmsh_connect (mms_io_t *io, void *data, const char *url, int bandwidth)
   this->user_bandwidth  = bandwidth;
   this->http_request_number = 1;
 
-//  report_progress (stream, 0);
-
   if (this->proxy_url) {
     proxy_uri = gnet_uri_new(this->proxy_url);
     if (!proxy_uri) {
-- 
1.7.0

